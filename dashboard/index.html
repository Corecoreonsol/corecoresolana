<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="CORE Creative Dashboard - PFP Generator & Editor">
    <title>Creative Dashboard - CORE</title>
    
    <!-- Favicon -->
    <link rel="icon" type="image/jpeg" href="/images/favicon.jpg">
    
    <!-- Preload Critical Assets -->
    <link rel="preload" href="/dashboard/newcorelogo.svg" as="image" type="image/svg+xml">
    
    <style>
        /* ===== CORE COLOR PALETTE - EXACT FROM MAIN SITE ===== */
        :root {
            --core-blue: #0099ff;
            --core-blue-dark: #0066cc;
            --core-cyan: #00ffff;
            --core-dark-blue: #000408;
            --core-navy: #000205;
            --core-glow-blue: #0099ff80;
            --core-glow-cyan: #00ffff40;
            --core-text-blue: #66ccff;
            --core-accent: #0080ff;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html {
            scroll-behavior: smooth;
        }

        /* Force cursor visibility on all interactive elements */
        button, a, input, select, textarea, [role="button"], .clickable {
            cursor: pointer !important;
        }

        input[type="file"] {
            cursor: pointer !important;
        }

        canvas {
            cursor: grab !important;
        }

        canvas:active {
            cursor: grabbing !important;
        }

        html {
            scroll-behavior: smooth;
        }
        
        html, body {
            height: 100%;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            cursor: default !important;
        }
        
        /* Hide scrollbar for all browsers */
        html::-webkit-scrollbar,
        body::-webkit-scrollbar {
            display: none;
            width: 0;
            height: 0;
        }
        
        html,
        body {
            -ms-overflow-style: none;  /* IE and Edge */
            scrollbar-width: none;  /* Firefox */
        }
        
        /* Desktop only - lock overflow */
        @media (min-width: 1025px) {
            html, body {
                overflow: hidden;
            }
        }
        
        /* Mobile and tablet - allow scrolling without scrollbar */
        @media (max-width: 1024px) {
            html, body {
                overflow-y: scroll !important;
                overflow-x: hidden;
                height: auto;
                min-height: 100vh;
                position: relative;
                scroll-behavior: smooth;
            }

            /* Ensure smooth scrolling on mobile */
            body {
                -webkit-overflow-scrolling: touch;
                overscroll-behavior: contain;
            }
            
            .dashboard-wrapper {
                height: auto !important;
                min-height: 100vh;
            }
        }

        body {
            background: radial-gradient(ellipse at center, #001433 0%, #001433 30%, #001228 50%, #000a1a 75%, #000204 100%);
            background-attachment: fixed;
            color: white;
            position: relative;
        }
        
        /* Animated Stars Background */
        .stars-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            pointer-events: none;
        }
        
        .star {
            position: absolute;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            animation: twinkle linear infinite;
        }

        @keyframes twinkle {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }

        /* ===== DASHBOARD CONTAINER ===== */
        .dashboard-wrapper {
            position: relative;
            z-index: 1;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* ===== DASHBOARD HEADER ===== */
        .dashboard-header {
            background: rgba(0, 25, 40, 0.3);
            backdrop-filter: blur(15px);
            border: none;
            border-bottom: 1px solid rgba(0, 153, 255, 0.2);
            padding: 0.5rem 1.2rem; /* Zmniejszone z 0.6rem */
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
            position: relative;
            z-index: 100;
            height: 60px; /* Zmniejszone z 65px */
        }

        .dashboard-logo {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            text-decoration: none;
            cursor: pointer !important;
            z-index: 1000;
            pointer-events: auto;
        }

        .dashboard-logo img {
            width: 80px;
            height: 80px;
            transform: translateY(1px);
        }

        .dashboard-logo h1 {
            font-size: 1rem;
            color: var(--core-cyan);
            font-weight: 200;
            letter-spacing: 0.15em;
            text-transform: uppercase;
            text-shadow: 0 0 10px var(--core-glow-cyan);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        .back-btn {
            padding: 14px 32px;
            background: rgba(0, 25, 40, 0.3);
            border: none;
            color: var(--core-text-blue);
            border-radius: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 0.9rem;
            font-weight: 200;
            letter-spacing: 0.15em;
            text-transform: uppercase;
            cursor: pointer !important;
            text-decoration: none;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1), 0 2px 6px rgba(0, 0, 0, 0.05);
            text-shadow: 0 0 10px var(--core-glow-blue);
            position: relative;
            overflow: hidden;
            z-index: 1000;
            pointer-events: auto;
            display: inline-block;
        }

        .back-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.6), transparent);
            transition: left 0.5s ease;
        }

        .back-btn:hover {
            background: rgba(0, 25, 40, 0.5);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.15), 0 4px 10px rgba(0, 0, 0, 0.08);
            text-shadow: 0 0 20px var(--core-cyan);
            transform: translateY(-2px) scale(1.05);
            color: var(--core-cyan);
        }

        .back-btn:hover::before {
            left: 100%;
        }

        /* ===== DASHBOARD LAYOUT ===== */
        .dashboard-container {
            flex: 1;
            display: grid;
            grid-template-columns: 30% 70%;
            gap: 0.8rem;
            padding: 0.8rem;
            padding-bottom: 1rem;
            overflow: hidden;
            min-height: 0;
            height: calc(100vh - 75px); /* Zmniejszone z 80px */
        }
        
        @media (max-width: 1024px) {
            .dashboard-container {
                overflow: visible !important;
            }
        }
        
        /* Ukryj scrollbar ca≈Çkowicie tylko dla dashboard container */

        /* ===== LEFT PANEL - PFP GENERATOR ===== */
        .pfp-panel {
            background: rgba(0, 25, 40, 0.3);
            backdrop-filter: blur(15px);
            border: none;
            border-radius: 0;
            padding: 1rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            height: 100%;
            position: relative;
            overflow: visible;
            touch-action: pan-y;
        }

        .pfp-panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.6), transparent);
            transition: left 0.5s ease;
        }

        .pfp-panel:hover::before {
            left: 100%;
        }

        .pfp-title {
            font-size: 0.8rem;
            color: var(--core-cyan);
            text-align: center;
            margin-bottom: 0.3rem;
            font-weight: 200;
            letter-spacing: 0.15em;
            text-transform: uppercase;
            text-shadow: 0 0 10px var(--core-glow-cyan);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        .pfp-subtitle {
            font-size: 0.65rem;
            color: rgba(255, 255, 255, 0.7);
            text-align: center;
            margin-bottom: 1rem;
            font-weight: 200;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        .pfp-upload-area {
            flex: 1;
            background: rgba(0, 4, 8, 0.5);
            border: 2px dashed rgba(0, 153, 255, 0.3);
            border-radius: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 1rem;
            cursor: pointer !important;
            transition: all 0.3s ease;
            position: relative;
            min-height: 200px;
        }

        .pfp-upload-area:hover {
            border-color: var(--core-cyan);
            background: rgba(0, 4, 8, 0.7);
        }

        .upload-icon {
            font-size: 2.5rem;
            color: var(--core-blue);
            margin-bottom: 0.8rem;
            opacity: 0.6;
        }

        .upload-text {
            font-size: 0.75rem;
            color: var(--core-text-blue);
            margin-bottom: 0.2rem;
            font-weight: 200;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        .upload-hint {
            font-size: 0.65rem;
            color: rgba(255, 255, 255, 0.5);
            margin-bottom: 0.8rem;
            font-weight: 200;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        .upload-button {
            padding: 8px 20px;
            background: rgba(0, 25, 40, 0.3);
            border: none;
            color: var(--core-text-blue);
            border-radius: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 0.75rem;
            font-weight: 200;
            letter-spacing: 0.15em;
            text-transform: uppercase;
            cursor: pointer !important;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1), 0 2px 6px rgba(0, 0, 0, 0.05);
            text-shadow: 0 0 10px var(--core-glow-blue);
            position: relative;
            overflow: hidden;
        }

        .upload-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.6), transparent);
            transition: left 0.5s ease;
        }

        .upload-button:hover {
            background: rgba(0, 25, 40, 0.5);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.15), 0 4px 10px rgba(0, 0, 0, 0.08);
            text-shadow: 0 0 20px var(--core-cyan);
            transform: translateY(-2px) scale(1.05);
            color: var(--core-cyan);
        }

        .upload-button:hover::before {
            left: 100%;
        }

        .generate-btn {
            width: 100%;
            max-width: 280px;
            margin-left: auto;
            margin-right: auto;
            padding: 10px 20px;
            margin-top: 0.8rem;
            background: rgba(0, 25, 40, 0.3);
            border: none;
            color: var(--core-text-blue);
            border-radius: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 0.7rem;
            font-weight: 200;
            letter-spacing: 0.15em;
            text-transform: uppercase;
            cursor: pointer !important;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1), 0 2px 6px rgba(0, 0, 0, 0.05);
            text-shadow: 0 0 10px var(--core-glow-blue);
            position: relative;
            overflow: hidden;
        }

        .generate-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 153, 255, 0.2), transparent);
            transition: left 0.6s ease;
        }

        .generate-btn:hover:not(:disabled) {
            background: rgba(0, 25, 40, 0.5);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.15), 0 4px 10px rgba(0, 0, 0, 0.08);
            text-shadow: 0 0 20px var(--core-cyan);
            transform: translateY(-2px) scale(1.05);
            color: var(--core-cyan);
        }

        .generate-btn:hover:not(:disabled)::before {
            left: 100%;
        }

        .generate-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed !important;
        }

        /* ===== RIGHT PANEL - CORE EDITOR ===== */
        .editor-panel {
            background: rgba(0, 25, 40, 0.3);
            backdrop-filter: blur(15px);
            border: none;
            border-radius: 0;
            padding: 1rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            height: 100%;
            position: relative;
            overflow: hidden;
            touch-action: pan-y;
        }

        .editor-panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.6), transparent);
            transition: left 0.5s ease;
        }

        .editor-panel:hover::before {
            left: 100%;
        }

        .editor-title {
            font-size: 0.8rem;
            color: var(--core-cyan);
            text-align: center;
            margin-bottom: 0.3rem;
            font-weight: 200;
            letter-spacing: 0.15em;
            text-transform: uppercase;
            text-shadow: 0 0 10px var(--core-glow-cyan);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        .editor-subtitle {
            font-size: 0.65rem;
            color: rgba(255, 255, 255, 0.7);
            text-align: center;
            margin-bottom: 0.8rem;
            font-weight: 200;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        .editor-canvas-area {
            width: 100%;
            flex: 1;
            min-height: 260px; /* Zmniejszone z 280px */
            max-height: 360px; /* Zmniejszone z 380px */
            background: rgba(0, 4, 8, 0.5);
            border: 1px solid rgba(0, 153, 255, 0.2);
            border-radius: 0;
            position: relative;
            overflow: hidden;
            margin-bottom: 0.6rem; /* Zmniejszone z 0.8rem */
        }

        .canvas-wrapper {
            width: 100%;
            height: 100%;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .editor-upload-placeholder {
            position: absolute;
            inset: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer !important;
            transition: all 0.3s ease;
        }

        .editor-upload-placeholder:hover {
            background: rgba(0, 153, 255, 0.05);
        }

        .editor-upload-icon {
            font-size: 3rem;
            margin-bottom: 0.8rem;
            opacity: 0.6;
        }

        #editorCanvas {
            width: 100%;
            height: 100%;
            display: block;
            cursor: grab !important;
        }

        #editorCanvas:active {
            cursor: grabbing !important;
        }

        .editor-controls {
            display: flex;
            flex-direction: row;
            gap: 0.4rem;
            flex-shrink: 0;
            align-items: stretch;
            width: 100%;
            height: 140px; /* Zmniejszone z 160px */
            overflow: hidden;
            margin-top: 0.3rem; /* Zmniejszone z 0.5rem */
            border: 1px solid rgba(0, 153, 255, 0.1);
            background: rgba(0, 4, 8, 0.1);
            padding: 0.25rem; /* Zmniejszone z 0.3rem */
        }

        .control-group {
            background: rgba(0, 4, 8, 0.3);
            border: 1px solid rgba(0, 153, 255, 0.1);
            border-radius: 0;
            padding: 0.25rem; /* Zmniejszone z 0.3rem */
            position: relative;
            flex: 1;
            min-width: 0;
            height: 100%;
            max-height: 100%;
            overflow-y: auto;
            overflow-x: hidden;
            margin: 0;
        }
        
        .control-group::-webkit-scrollbar {
            width: 4px;
        }
        
        .control-group::-webkit-scrollbar-track {
            background: rgba(0, 4, 8, 0.3);
        }
        
        .control-group::-webkit-scrollbar-thumb {
            background: rgba(0, 153, 255, 0.5);
            border-radius: 2px;
        }
        
        .control-group::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 153, 255, 0.7);
        }

        .control-group h3 {
            font-size: 0.6rem; /* Zmniejszone z 0.65rem */
            color: var(--core-cyan);
            margin-bottom: 0.3rem; /* Zmniejszone z 0.4rem */
            text-align: center;
            font-weight: 300;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            text-shadow: 0 0 8px var(--core-glow-cyan);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            white-space: nowrap;
            line-height: 1;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .control-button {
            width: 100%;
            padding: 5px 6px; /* Zmniejszone z 6px 6px */
            margin-bottom: 0.15rem; /* Zmniejszone z 0.2rem */
            background: rgba(0, 25, 40, 0.3);
            color: var(--core-text-blue);
            border: none;
            border-radius: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 0.6rem; /* Zmniejszone z 0.65rem */
            font-weight: 300;
            letter-spacing: 0.08em;
            line-height: 1.0; /* Zmniejszone z 1.1 */
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            text-transform: uppercase;
            cursor: pointer !important;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1), 0 2px 6px rgba(0, 0, 0, 0.05);
            text-shadow: 0 0 10px var(--core-glow-blue);
            position: relative;
            overflow: hidden;
        }

        .control-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.6), transparent);
            transition: left 0.5s ease;
        }

        .control-button:hover {
            background: rgba(0, 25, 40, 0.5);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.15), 0 4px 10px rgba(0, 0, 0, 0.08);
            text-shadow: 0 0 20px var(--core-cyan);
            transform: translateY(-2px) scale(1.05);
            color: var(--core-cyan);
        }

        .control-button:hover::before {
            left: 100%;
        }

        .control-button:disabled {
            opacity: 0.4;
            cursor: not-allowed !important;
            background: rgba(0, 25, 40, 0.2);
        }

        .control-button:disabled:hover {
            background: rgba(0, 25, 40, 0.2);
            transform: none;
            text-shadow: 0 0 10px var(--core-glow-blue);
            color: var(--core-text-blue);
        }

        .control-button:last-child {
            margin-bottom: 0;
        }

        .control-slider {
            margin-top: 0.2rem;
            margin-bottom: 0.2rem;
            width: 100%;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.3rem;
            font-size: 0.55rem;
            color: var(--core-text-blue);
            font-weight: 200;
            line-height: 1;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .control-slider input[type="range"] {
            width: 100%;
            height: 3px;
            background: rgba(0, 153, 255, 0.2);
            border-radius: 2px;
            outline: none;
            cursor: pointer !important;
            -webkit-appearance: none;
            appearance: none;
            margin: 0.2rem 0;
        }

        .control-slider input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            background: var(--core-text-blue);
            border-radius: 50%;
            cursor: pointer !important;
            box-shadow: 0 0 8px var(--core-glow-blue);
        }

        .control-slider input[type="range"]::-moz-range-thumb {
            width: 12px;
            height: 12px;
            background: var(--core-text-blue);
            border-radius: 50%;
            cursor: pointer !important;
            border: none;
            box-shadow: 0 0 8px var(--core-glow-blue);
        }

        /* Logo Color Picker */
        .logo-color-picker {
            width: 100%;
            height: 32px;
            cursor: pointer !important;
            border: 1px solid rgba(0, 153, 255, 0.3);
            background: rgba(0, 4, 8, 0.5);
            border-radius: 2px;
            outline: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            padding: 0;
            margin: 0.2rem 0;
        }

        .logo-color-picker::-webkit-color-swatch-wrapper {
            padding: 0;
            border: none;
        }

        .logo-color-picker::-webkit-color-swatch {
            border: 1px solid rgba(0, 153, 255, 0.5);
            border-radius: 1px;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.3);
        }

        .logo-color-picker::-moz-color-swatch {
            border: 1px solid rgba(0, 153, 255, 0.5);
            border-radius: 1px;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.3);
        }

        .logo-color-picker:hover {
            border-color: rgba(0, 153, 255, 0.6);
            box-shadow: 0 0 8px var(--core-glow-blue);
        }

        .logo-color-picker:focus {
            border-color: var(--core-text-blue);
            box-shadow: 0 0 12px var(--core-glow-blue);
        }

        .editor-file-input {
            display: none;
        }

        /* Core Style Selection */
        .style-toggle-btn {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: relative;
        }

        .toggle-arrow {
            font-size: 0.5rem;
            transition: transform 0.3s ease;
        }

        .style-toggle-btn.open .toggle-arrow {
            transform: rotate(180deg);
        }

        .core-style-dropdown {
            position: fixed;
            background: rgba(0, 4, 8, 0.98);
            border: 1px solid rgba(0, 153, 255, 0.3);
            border-radius: 0;
            margin-top: 0;
            max-height: 120px;
            min-width: 120px;
            max-width: 200px;
            overflow-y: auto;
            z-index: 10000;
            backdrop-filter: blur(15px);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        .core-style-dropdown::-webkit-scrollbar {
            width: 4px;
        }

        .core-style-dropdown::-webkit-scrollbar-track {
            background: rgba(0, 4, 8, 0.5);
        }

        .core-style-dropdown::-webkit-scrollbar-thumb {
            background: rgba(0, 153, 255, 0.5);
            border-radius: 0;
        }

        .core-style-option {
            padding: 0.4rem 0.5rem;
            cursor: pointer !important;
            transition: all 0.2s ease;
            font-size: 0.6rem;
            color: var(--core-text-blue);
            font-weight: 200;
            letter-spacing: 0.06em;
            line-height: 1.3;
            text-transform: uppercase;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            border-bottom: 1px solid rgba(0, 153, 255, 0.1);
            white-space: nowrap;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .core-style-option:last-child {
            border-bottom: none;
        }

        /* Default colors for raptorcore, pumpcore, and auracore */
        .core-style-option[data-style="raptorcore"] {
            color: #ff8c00;
            border-bottom: 1px solid rgba(255, 140, 0, 0.1);
        }

        .core-style-option[data-style="pumpcore"] {
            color: #83efaa;
            border-bottom: 1px solid rgba(131, 239, 170, 0.1);
        }

        .core-style-option[data-style="auracore"] {
            color: #a6e244;
            border-bottom: 1px solid rgba(166, 226, 68, 0.1);
        }

        .core-style-option:hover {
            background: rgba(0, 153, 255, 0.15);
            color: var(--core-cyan);
            text-shadow: 0 0 10px var(--core-cyan);
        }

        /* Specific hover colors for raptorcore, pumpcore, and auracore */
        .core-style-option[data-style="raptorcore"]:hover {
            background: rgba(255, 140, 0, 0.15);
            color: #ff8c00;
            text-shadow: 0 0 10px #ff8c00;
        }

        .core-style-option[data-style="pumpcore"]:hover {
            background: rgba(131, 239, 170, 0.15);
            color: #83efaa;
            text-shadow: 0 0 10px #83efaa;
        }

        .core-style-option[data-style="auracore"]:hover {
            background: rgba(166, 226, 68, 0.15);
            color: #a6e244;
            text-shadow: 0 0 10px #a6e244;
        }

        .core-style-option.selected {
            background: rgba(0, 153, 255, 0.25);
            color: var(--core-cyan);
            border-left: 2px solid var(--core-cyan);
        }

        .core-style-option[data-style="raptorcore"].selected {
            background: rgba(255, 140, 0, 0.25);
            color: #ff8c00;
            border-left: 2px solid #ff8c00;
        }

        .core-style-option[data-style="pumpcore"].selected {
            background: rgba(131, 239, 170, 0.25);
            color: #83efaa;
            border-left: 2px solid #83efaa;
        }

        .core-style-option[data-style="auracore"].selected {
            background: rgba(166, 226, 68, 0.25);
            color: #a6e244;
            border-left: 2px solid #a6e244;
        }

        .core-style-card.selected .core-style-name {
            color: var(--core-cyan);
        }

        /* Loading spinner for generate button */
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* ===== RESPONSIVE ===== */
        @media (max-width: 1400px) {
            .dashboard-container {
                grid-template-columns: 32% 68%;
                gap: 0.6rem;
                height: calc(100vh - 75px);
                padding: 0.6rem;
            }
            
            .editor-canvas-area {
                max-height: 360px;
                min-height: 250px;
            }
            
            .editor-controls {
                height: 130px;
                padding: 0.2rem;
            }
            
            .control-group {
                height: 100%;
                max-height: 100%;
                margin: 0;
                overflow-y: auto;
                padding: 0.25rem;
            }
            
            .control-button {
                font-size: 0.58rem;
                padding: 5px 6px;
                margin-bottom: 0.15rem;
            }
            
            .control-group h3 {
                font-size: 0.58rem;
                margin-bottom: 0.3rem;
            }
        }

        /* Specjalny fix dla ekran√≥w 13-calowych (1360px-1440px) */
        @media (min-width: 1300px) and (max-width: 1440px) {
            .dashboard-container {
                height: calc(100vh - 80px);
                padding: 0.5rem;
                gap: 0.5rem;
            }
            
            .dashboard-header {
                height: 60px;
                padding: 0.5rem 1rem;
            }
            
            .editor-canvas-area {
                max-height: 320px;
                min-height: 240px;
                flex-shrink: 0;
            }
            
            .editor-controls {
                height: 110px;
                gap: 0.3rem;
                padding: 0.2rem;
                flex-shrink: 0;
                margin-top: 0.3rem;
            }
            
            .control-group {
                padding: 0.2rem;
                height: 100%;
                max-height: 100%;
                overflow-y: auto;
            }
            
            .control-button {
                font-size: 0.55rem;
                padding: 4px 5px;
                margin-bottom: 0.1rem;
                line-height: 1.1;
            }
            
            .control-group h3 {
                font-size: 0.55rem;
                margin-bottom: 0.25rem;
            }
            
            .pfp-panel, .editor-panel {
                padding: 0.8rem;
            }
            
            .pfp-upload-area {
                min-height: 180px;
            }
        }

        @media (max-width: 1200px) {
            .dashboard-container {
                grid-template-columns: 35% 65%;
                height: calc(100vh - 70px);
            }
            
            .pfp-title, .editor-title {
                font-size: 0.75rem;
            }
            
            .control-button {
                font-size: 0.6rem;
                padding: 6px 8px;
            }
            
            .control-group {
                padding: 0.3rem;
            }
            
            .control-group h3 {
                font-size: 0.6rem;
            }
            
            .editor-canvas-area {
                max-height: 380px;
            }
            
            .editor-controls {
                height: 120px;
                padding: 0.2rem;
            }
            
            .control-group {
                height: 100%;
                max-height: 100%;
                margin: 0;
                overflow-y: auto;
            }
        }

        /* Tablet optimization - enable scrolling */
        @media (max-width: 1024px) {
            html, body {
                overflow-y: auto !important;
                -webkit-overflow-scrolling: touch;
                height: auto;
            }
            
            body {
                min-height: 100vh;
                padding-bottom: 0.5rem;
            }
            
            .dashboard-container {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto;
                gap: 0.8rem;
                padding: 0.8rem;
                height: auto !important;
                min-height: calc(100vh - 80px);
                overflow: visible !important;
                padding-bottom: 0.5rem;
                touch-action: pan-y;
            }

            .pfp-panel {
                min-height: 380px;
                height: auto !important;
                overflow: visible;
            }
            
            .editor-panel {
                min-height: 500px;
                height: auto !important;
                margin-bottom: 8vh; /* Slightly reduced from 10vh */
                overflow: visible !important;
            }

            .editor-canvas-area {
                min-height: 200px;
                max-height: 280px;
                flex: 1;
            }

            .editor-controls {
                height: 120px;
                gap: 0.3rem;
                padding: 0.2rem;
                overflow: visible !important;
            }
            
            .control-group {
                padding: 0.25rem;
                height: 100%;
                max-height: 100%;
                margin: 0;
                overflow-y: auto;
            }
            
            .control-button {
                padding: 6px 4px;
                font-size: 0.55rem;
                margin-bottom: 0.25rem;
            }
            
            .control-group h3 {
                font-size: 0.55rem;
                margin-bottom: 0.3rem;
            }
            
            .pfp-upload-area {
                min-height: 160px;
            }
            
            .upload-icon {
                font-size: 2rem;
                margin-bottom: 0.6rem;
            }
            
            .editor-upload-icon {
                font-size: 2.5rem;
            }
        }

        @media (max-width: 768px) {
            .dashboard-header {
                padding: 0.6rem 1rem;
            }

            .dashboard-logo h1 {
                font-size: 0.85rem;
            }
            
            .dashboard-logo img {
                width: 50px;
                height: 50px;
            }
            
            .back-btn {
                font-size: 0.7rem;
                padding: 10px 20px;
            }

            body {
                padding-bottom: 0.5rem;
            }

            .dashboard-container {
                padding: 0.6rem;
                gap: 0.8rem;
                height: auto;
                min-height: 100vh;
                grid-template-rows: auto auto;
                overflow: visible;
                padding-bottom: 0.5rem;
            }
            
            .pfp-panel {
                padding: 0.8rem;
                min-height: 350px;
                height: auto;
            }
            
            .editor-panel {
                padding: 0.8rem;
                min-height: 700px; /* Increased from 450px to fit all controls */
                height: auto;
            }

            .editor-canvas-area {
                min-height: 250px; /* Increased from 180px */
                max-height: 320px; /* Increased from 240px */
                flex-shrink: 0;
            }
            
            .editor-controls {
                flex-direction: column;
                height: auto;
                min-height: 500px; /* Increased from 300px */
                gap: 0.4rem;
                padding: 0.25rem;
                overflow-y: visible;
            }
            
            .control-group {
                padding: 0.3rem;
                height: auto;
                min-height: 80px; /* Increased from 60px */
                max-height: none;
                margin: 0;
                overflow-y: visible;
            }

            .control-button {
                font-size: 0.5rem;
                padding: 5px 3px;
            }
            
            .control-group h3 {
                font-size: 0.5rem;
            }
            
            .pfp-upload-area {
                min-height: 120px;
            }
            
            .upload-icon {
                font-size: 1.8rem;
                margin-bottom: 0.5rem;
            }
            
            .editor-upload-icon {
                font-size: 2rem;
            }
        }

        @media (max-width: 640px) {
            body {
                padding-bottom: 0.5rem;
            }

            .dashboard-container {
                padding: 0.5rem;
                height: auto !important;
                min-height: 100vh;
                grid-template-rows: auto auto;
                overflow: visible !important;
                padding-bottom: 0.5rem;
            }
            
            .pfp-panel {
                padding: 0.6rem;
                min-height: 380px;
                height: auto !important;
                overflow: visible !important;
            }
            
            .editor-panel {
                padding: 0.6rem;
                min-height: 650px; /* Increased from 400px */
                height: auto !important;
                overflow: visible !important;
            }
            
            .editor-controls {
                flex-direction: column;
                height: auto !important;
                min-height: 400px;
                gap: 0.35rem;
                padding: 0.2rem;
                overflow: visible !important;
            }
            
            .control-group {
                padding: 0.25rem;
                height: auto !important;
                min-height: 70px; /* Increased from 55px */
                max-height: none;
                flex: none;
                margin: 0;
                overflow: visible !important;
            }
            
            .control-button {
                padding: 4px 2px;
                font-size: 0.45rem;
                margin-bottom: 0.2rem;
            }
            
            .control-group h3 {
                font-size: 0.45rem;
                margin-bottom: 0.25rem;
            }
            
            .editor-canvas-area {
                min-height: 200px; /* Increased from 150px */
                max-height: 280px; /* Increased from 200px */
            }
            
            .pfp-upload-area {
                min-height: 250px;
                max-height: 250px;
                aspect-ratio: 1;
                width: 250px;
                margin: 0 auto;
                padding: 0.6rem;
            }
            
            .upload-icon {
                font-size: 1.5rem;
                margin-bottom: 0.4rem;
            }
            
            .upload-text {
                font-size: 0.65rem;
            }
            
            .upload-hint {
                font-size: 0.55rem;
                margin-bottom: 0.6rem;
            }
            
            .upload-button {
                font-size: 0.6rem;
                padding: 6px 12px;
            }
            
            .generate-btn {
                font-size: 0.6rem;
                padding: 8px 16px;
            }
        }

        @media (max-width: 480px) {
            .dashboard-logo img {
                width: 40px;
                height: 40px;
            }
            
            .dashboard-logo h1 {
                display: none;
            }
            
            .back-btn {
                font-size: 0.65rem;
                padding: 8px 16px;
            }
            
            .pfp-title, .editor-title {
                font-size: 0.65rem;
            }
            
            .pfp-subtitle, .editor-subtitle {
                font-size: 0.5rem;
            }

            body {
                padding-bottom: 0.5rem;
            }

            .dashboard-container {
                padding: 0.4rem;
                gap: 0.6rem;
                height: auto !important;
                min-height: 100vh;
                overflow: visible !important;
                padding-bottom: 0.5rem;
                touch-action: pan-y;
            }
            
            .pfp-panel {
                min-height: 380px;
                height: auto !important;
                overflow: visible !important;
            }
            
            .editor-panel {
                min-height: 600px;
                height: auto !important;
                overflow: visible !important;
            }

            .editor-canvas-area {
                min-height: 200px;
                max-height: 280px;
            }
            
            .canvas-wrapper {
                width: 100%;
                height: 100%;
                position: relative;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            #editorCanvas {
                width: 100%;
                height: 100%;
                object-fit: contain;
                display: block;
            }
            
            .editor-controls {
                flex-direction: column;
                height: auto !important;
                min-height: 400px;
                padding: 0.2rem;
                gap: 0.3rem;
                overflow: visible !important;
            }
            
            .control-group {
                height: auto !important;
                min-height: 75px; /* Increased from 50px */
                max-height: none;
                flex: none;
                margin: 0;
                overflow: visible !important;
            }
            
            .control-button {
                font-size: 0.4rem;
                padding: 3px 2px;
            }
            
            .control-group h3 {
                font-size: 0.4rem;
            }
        }

        /* Mobile Notice Styles */
        .mobile-notice {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 25, 40, 0.95);
            backdrop-filter: blur(10px);
            border-top: 1px solid var(--core-blue);
            z-index: 10000;
            display: none;
        }

        .mobile-notice-content {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 20px;
            max-width: 100%;
        }

        .mobile-notice-text {
            color: var(--core-text-blue);
            font-size: 0.85rem;
            font-weight: 300;
            letter-spacing: 0.05em;
            flex: 1;
        }

        .mobile-notice-close {
            background: none;
            border: none;
            color: var(--core-cyan);
            font-size: 1.5rem;
            font-weight: bold;
            cursor: pointer;
            padding: 0;
            margin-left: 15px;
            line-height: 1;
            transition: all 0.3s ease;
        }

        .mobile-notice-close:hover {
            color: #ffffff;
            transform: scale(1.1);
        }

        @media (max-width: 768px) {
            .mobile-notice {
                display: block;
            }

            .mobile-notice-text {
                font-size: 0.75rem;
            }
        }
    </style>
</head>
<body>
    <!-- Mobile Notice -->
    <div class="mobile-notice" id="mobileNotice">
        <div class="mobile-notice-content">
            <span class="mobile-notice-text">üì± For the best experience, please use the desktop version on a PC.</span>
            <button class="mobile-notice-close" onclick="closeMobileNotice()">√ó</button>
        </div>
    </div>

    <!-- Animated Stars Background -->
    <div class="stars-container" id="starsContainer"></div>

    <div class="dashboard-wrapper">
        <!-- Dashboard Header -->
        <header class="dashboard-header">
            <a href="/" class="dashboard-logo">
                <img src="/dashboard/newcorelogo.svg" alt="CORE">
                <h1>CREATIVE DASHBOARD</h1>
            </a>
            <a href="/" class="back-btn">‚Üê BACK TO HOME</a>
        </header>

        <!-- Dashboard Main Container -->
        <div class="dashboard-container">
        <!-- LEFT: PFP GENERATOR -->
        <div class="pfp-panel">
            <h3 class="pfp-title">PFP GENERATOR</h3>
            <p class="pfp-subtitle">Transform your image with CORE aura effects</p>
            
            <div class="pfp-upload-area" id="pfpMainArea">
                <div class="upload-icon">+</div>
                <div class="upload-text">Upload or drag an image here</div>
                <div class="upload-hint">to generate its aura</div>
                <button class="upload-button" id="pfpUploadBtn">UPLOAD AN IMAGE</button>
                <input type="file" id="pfpImageInput" accept="image/*" style="display: none;">
            </div>
            
            <button class="generate-btn" id="pfpGenerateBtn" disabled>
                Generate CORE Aura
            </button>
        </div>

        <!-- RIGHT: CORE EDITOR -->
        <div class="editor-panel">
            <h3 class="editor-title">CORE EDITOR</h3>
            <p class="editor-subtitle">Upload image to add CORE logo overlay</p>
            
            <div class="editor-canvas-area">
                <div class="canvas-wrapper" id="canvasWrapper">
                    <div class="editor-upload-placeholder" id="uploadPlaceholder">
                        <div class="editor-upload-icon">üìÅ</div>
                        <p style="font-size: 1rem; margin-bottom: 0.4rem; font-weight: 300;">Upload your image</p>
                        <p style="font-size: 0.85rem; opacity: 0.6;">Click to browse or drag and drop</p>
                    </div>
                    <canvas id="editorCanvas" style="display: none;"></canvas>
                </div>
            </div>
            
            <div class="editor-controls">
                <!-- Upload Controls -->
                <div class="control-group">
                    <h3>üìÇ MEDIA</h3>
                    <button class="control-button" id="uploadMediaBtn">Upload</button>
                    <input type="file" id="editorMediaInput" class="editor-file-input" accept="image/*">
                    <button class="control-button" id="clearCanvasBtn" style="display: none;">Clear</button>
                </div>
                
                <!-- Logo Controls -->
                <div class="control-group" id="logoControls">
                    <h3>‚ú® LOGO</h3>
                    <button class="control-button" id="addLogoBtn" disabled>Add</button>
                    <button class="control-button" id="removeLogoBtn" style="display: none;">Remove</button>
                    <button class="control-button" id="centerLogoBtn" style="display: none;">Center</button>
                    
                    <div class="control-slider" id="logoSizeControl" style="display: none;">
                        <div class="slider-label">
                            <span>Size</span>
                            <span id="logoSizeValue">100</span>
                        </div>
                        <input type="range" id="logoSize" min="50" max="500" value="100">
                    </div>
                    
                    <div class="control-slider" id="logoOpacityControl" style="display: none;">
                        <div class="slider-label">
                            <span>Opacity</span>
                            <span id="logoOpacityValue">100%</span>
                        </div>
                        <input type="range" id="logoOpacity" min="0" max="100" value="100">
                    </div>
                    
                    <div class="control-slider" id="logoColorControl" style="display: none;">
                        <div class="slider-label">
                            <span>Logo Color</span>
                            <span id="logoColorValue">#00FFFF</span>
                        </div>
                        <input type="color" id="logoColor" value="#00FFFF" class="logo-color-picker">
                    </div>
                </div>
                
                <!-- Core Style Selection -->
                <div class="control-group" id="coreStyleControls">
                    <h3>üé® Choose Your Core</h3>
                    <button class="control-button style-toggle-btn" id="styleToggleBtn" disabled>
                        <span id="selectedStyleName">Select Style</span>
                        <span class="toggle-arrow">‚ñº</span>
                    </button>
                    <div class="core-style-dropdown" id="styleDropdown" style="display: none;">
                        <div class="core-style-option" data-style="raptorcore">RAPTORCORE</div>
                        <div class="core-style-option" data-style="pumpcore">PUMPCORE</div>
                        <div class="core-style-option" data-style="auracore">AURACORE</div>
                        <div class="core-style-option" data-style="cybercore">CYBERCORE</div>
                        <div class="core-style-option" data-style="dreamcore">DREAMCORE</div>
                        <div class="core-style-option" data-style="weirdcore">WEIRDCORE</div>
                        <div class="core-style-option" data-style="vaporcore">VAPORCORE</div>
                        <div class="core-style-option" data-style="anime">ANIMECORE</div>
                        <div class="core-style-option" data-style="manga">MANGACORE</div>
                        <div class="core-style-option" data-style="cottage">COTTAGECORE</div>
                        <div class="core-style-option" data-style="hopecore">HOPECORE</div>
                        <div class="core-style-option" data-style="royal">ROYALCORE</div>
                        <div class="core-style-option" data-style="moneycore">MONEYCORE</div>
                        <div class="core-style-option" data-style="frutiger">FRUTIGER AERO</div>
                        <div class="core-style-option" data-style="ravecore">RAVECORE</div>
                        <div class="core-style-option" data-style="pixelcore">PIXELCORE</div>
                        <div class="core-style-option" data-style="alonecore">ALONECORE</div>
                        <div class="core-style-option" data-style="clowncore">CLOWNCORE</div>
                        <div class="core-style-option" data-style="spacecore">SPACECORE</div>
                        <div class="core-style-option" data-style="catcore">CATCORE</div>
                        <div class="core-style-option" data-style="dogcore">DOGCORE</div>
                    </div>
                    <button class="control-button" id="applyStyleBtn" style="display: none; margin-top: 0.25rem;">Apply</button>
                </div>
                
                <!-- Export Controls -->
                <div class="control-group" id="exportControls">
                    <h3>üíæ EXPORT</h3>
                    <button class="control-button" id="exportBtn" disabled>Download</button>
                    <p id="exportNote" style="font-size: 0.35rem; color: rgba(255,255,255,0.5); margin-top: 0.1rem; text-align: center; line-height: 1;">
                        Ready
                    </p>
                </div>
            </div>
        </div>
    </div>
    </div>

    <script>
        // ===== STARS ANIMATION =====
        function createStars() {
            const container = document.getElementById('starsContainer');
            const starCount = 50;
            
            for (let i = 0; i < starCount; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                star.style.width = Math.random() * 2 + 1 + 'px';
                star.style.height = star.style.width;
                star.style.left = Math.random() * 100 + '%';
                star.style.top = Math.random() * 100 + '%';
                star.style.animationDuration = Math.random() * 3 + 2 + 's';
                star.style.animationDelay = Math.random() * 2 + 's';
                container.appendChild(star);
            }
        }
        
        createStars();
    </script>

    <script>
        // ===== PFP GENERATOR FUNCTIONALITY =====
        let uploadedPfpFile = null;
        let uploadedPfpImage = null;

        const pfpMainArea = document.getElementById('pfpMainArea');
        const pfpUploadBtn = document.getElementById('pfpUploadBtn');
        const pfpImageInput = document.getElementById('pfpImageInput');
        const pfpGenerateBtn = document.getElementById('pfpGenerateBtn');

        // Upload handlers
        pfpUploadBtn.addEventListener('click', () => pfpImageInput.click());
        pfpMainArea.addEventListener('click', (e) => {
            if (e.target === pfpMainArea || e.target.classList.contains('upload-icon') || 
                e.target.classList.contains('upload-text') || e.target.classList.contains('upload-hint')) {
                pfpImageInput.click();
            }
        });
        
        // Drag & Drop for PFP Generator
        pfpMainArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.stopPropagation();
            pfpMainArea.style.borderColor = 'var(--core-cyan)';
            pfpMainArea.style.background = 'rgba(0, 255, 255, 0.05)';
        });
        
        pfpMainArea.addEventListener('dragleave', (e) => {
            e.preventDefault();
            e.stopPropagation();
            pfpMainArea.style.borderColor = 'rgba(0, 153, 255, 0.3)';
            pfpMainArea.style.background = 'rgba(0, 25, 40, 0.2)';
        });
        
        pfpMainArea.addEventListener('drop', (e) => {
            e.preventDefault();
            e.stopPropagation();
            pfpMainArea.style.borderColor = 'rgba(0, 153, 255, 0.3)';
            pfpMainArea.style.background = 'rgba(0, 25, 40, 0.2)';
            
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                const file = files[0];
                if (file.type.startsWith('image/')) {
                    // Trigger the same upload handler
                    uploadedPfpFile = file;
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        uploadedPfpImage = new Image();
                        // crossOrigin nie jest potrzebny dla data URLs z FileReader
                        // uploadedPfpImage.crossOrigin = 'anonymous';
                        uploadedPfpImage.onload = () => {
                            pfpMainArea.style.backgroundImage = `url('${event.target.result}')`;
                            pfpMainArea.style.backgroundSize = 'cover';
                            pfpMainArea.style.backgroundPosition = 'center';
                            pfpMainArea.innerHTML = '<div style="position: absolute; bottom: 10px; right: 10px; background: rgba(0,0,0,0.7); padding: 0.3rem 0.5rem; border-radius: 0; font-size: 0.65rem; text-transform: uppercase; letter-spacing: 0.1em;">‚úì Ready</div>';
                            pfpGenerateBtn.disabled = false;
                            pfpGenerateBtn.textContent = 'Generate CORE Aura';
                        };
                        uploadedPfpImage.src = event.target.result;
                    };
                    reader.readAsDataURL(file);
                }
            }
        });

        pfpImageInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file && file.type.startsWith('image/')) {
                uploadedPfpFile = file;
                const reader = new FileReader();
                reader.onload = (event) => {
                    uploadedPfpImage = new Image();
                    // crossOrigin nie jest potrzebny dla data URLs z FileReader
                    // uploadedPfpImage.crossOrigin = 'anonymous';
                    uploadedPfpImage.onload = () => {
                        pfpMainArea.style.backgroundImage = `url('${event.target.result}')`;
                        pfpMainArea.style.backgroundSize = 'cover';
                        pfpMainArea.style.backgroundPosition = 'center';
                        pfpMainArea.innerHTML = '<div style="position: absolute; bottom: 10px; right: 10px; background: rgba(0,0,0,0.7); padding: 0.3rem 0.5rem; border-radius: 0; font-size: 0.65rem; text-transform: uppercase; letter-spacing: 0.1em;">‚úì Ready</div>';
                        pfpGenerateBtn.disabled = false;
                        pfpGenerateBtn.textContent = 'Generate CORE Aura';
                    };
                    uploadedPfpImage.src = event.target.result;
                };
                reader.readAsDataURL(file);
            }
        });

        // Generate CORE Aura with API
        pfpGenerateBtn.addEventListener('click', async () => {
            if (!uploadedPfpFile) return;

            pfpGenerateBtn.disabled = true;
            pfpGenerateBtn.innerHTML = `
                <div style="display: flex; align-items: center; justify-content: center; gap: 0.5rem;">
                    <div style="width: 12px; height: 12px; border: 2px solid transparent; border-top: 2px solid currentColor; border-radius: 50%; animation: spin 1s linear infinite;"></div>
                    Generating...
                </div>
            `;

            try {
                const formData = new FormData();
                formData.append('image', uploadedPfpFile);

                const response = await fetch('/api/generate-avatar', {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    let msg = `API error: ${response.status}`;
                    try {
                        const err = await response.json();
                        if (err?.code || err?.error || err?.details) {
                            msg += ` - ${[err.code, err.error, err.details].filter(Boolean).join(' | ')}`;
                        }
                    } catch {}
                    throw new Error(msg);
                }

                const result = await response.json();

                if (result.image) {
                    const imageUrl = `data:image/png;base64,${result.image}`;
                    showPfpResult(imageUrl);
                } else {
                    throw new Error(result.error || 'Generation failed');
                }

            } catch (error) {
                console.error('Error generating CORE aura:', error);
                alert(`Error: ${error.message}\n\nPlease try again or use a different image.`);
                pfpGenerateBtn.disabled = false;
                pfpGenerateBtn.textContent = 'Generate CORE Aura';
            }
        });

        function showPfpResult(imageUrl) {
            pfpMainArea.style.backgroundImage = `url('${imageUrl}')`;
            pfpMainArea.innerHTML = `
                <div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; display: flex; flex-direction: column; align-items: center; justify-content: center; background: rgba(0,0,0,0.7);">
                    <div style="font-size: 0.75rem; color: var(--core-cyan); margin-bottom: 1rem; text-transform: uppercase; letter-spacing: 0.1em;">‚ú® Transformation Complete</div>
                    <button id="downloadPfpResult" style="padding: 0.6rem 1.2rem; background: rgba(0, 25, 40, 0.6); border: none; color: var(--core-cyan); border-radius: 0; font-family: 'Orbitron', monospace; font-size: 0.7rem; font-weight: 300; letter-spacing: 0.1em; text-transform: uppercase; cursor: pointer; margin-bottom: 0.5rem;">Download</button>
                    <button id="pfpNewImage" style="padding: 0.6rem 1.2rem; background: rgba(0, 25, 40, 0.4); border: none; color: var(--core-text-blue); border-radius: 0; font-family: 'Orbitron', monospace; font-size: 0.7rem; font-weight: 300; letter-spacing: 0.1em; text-transform: uppercase; cursor: pointer;">New Image</button>
                </div>
            `;

            document.getElementById('downloadPfpResult').addEventListener('click', () => {
                const a = document.createElement('a');
                a.href = imageUrl;
                a.download = `core-aura-${Date.now()}.png`;
                a.click();
            });

            document.getElementById('pfpNewImage').addEventListener('click', () => {
                resetPfpGenerator();
            });

            pfpGenerateBtn.style.display = 'none';
        }

        function resetPfpGenerator() {
            pfpMainArea.style.backgroundImage = '';
            pfpMainArea.innerHTML = `
                <div class="upload-icon">+</div>
                <div class="upload-text">Upload or drag an image here</div>
                <div class="upload-hint">to generate its aura</div>
                <button class="upload-button" id="pfpUploadBtn2">UPLOAD AN IMAGE</button>
            `;
            document.getElementById('pfpUploadBtn2').addEventListener('click', () => pfpImageInput.click());
            uploadedPfpFile = null;
            uploadedPfpImage = null;
            pfpGenerateBtn.style.display = 'block';
            pfpGenerateBtn.disabled = true;
            pfpGenerateBtn.textContent = 'Generate CORE Aura';
            pfpImageInput.value = '';
        }

        // ===== CORE EDITOR FUNCTIONALITY =====
        class CoreEditor {
            constructor() {
                this.canvas = document.getElementById('editorCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.uploadPlaceholder = document.getElementById('uploadPlaceholder');
                this.canvasWrapper = document.getElementById('canvasWrapper');
                
                // Buttons
                this.uploadMediaBtn = document.getElementById('uploadMediaBtn');
                this.editorMediaInput = document.getElementById('editorMediaInput');
                this.clearCanvasBtn = document.getElementById('clearCanvasBtn');
                this.addLogoBtn = document.getElementById('addLogoBtn');
                this.removeLogoBtn = document.getElementById('removeLogoBtn');
                this.centerLogoBtn = document.getElementById('centerLogoBtn');
                this.exportBtn = document.getElementById('exportBtn');
                
                // Controls
                this.logoControls = document.getElementById('logoControls');
                this.exportControls = document.getElementById('exportControls');
                this.logoSizeControl = document.getElementById('logoSizeControl');
                this.logoOpacityControl = document.getElementById('logoOpacityControl');
                this.logoColorControl = document.getElementById('logoColorControl');
                this.logoSizeSlider = document.getElementById('logoSize');
                this.logoSizeValue = document.getElementById('logoSizeValue');
                this.logoOpacitySlider = document.getElementById('logoOpacity');
                this.logoOpacityValue = document.getElementById('logoOpacityValue');
                this.logoColorPicker = document.getElementById('logoColor');
                this.logoColorValue = document.getElementById('logoColorValue');
                
                // Core Style Controls
                this.coreStyleControls = document.getElementById('coreStyleControls');
                this.styleToggleBtn = document.getElementById('styleToggleBtn');
                
                // State
                this.currentMedia = null;
                this.mediaType = 'image';
                this.logo = null;
                this.logoImage = null;
                this.logoImageLoaded = false;
                this.logoColor = '#00FFFF'; // Default cyan color
                this.logoSubject = null; // Selected subject core
                this.selectedCoreStyle = null;
                // Robust aspect ratio cache for logo (handles SVG reliably)
                this.logoAspectRatio = null; // width / height
                this.logoAspectRatioPixels = null; // derived from visible content bbox
                this.logoBitmap = null; // rasterized PNG version of the logo for iOS/mobile stability
                this.coloredLogoBitmap = null; // cached colored version to avoid re-processing
                this.lastLogoColor = null; // track color changes
                
                this.isDragging = false;
                this.dragOffset = { x: 0, y: 0 };
                // Normalized Y anchor within the logo image (0..1),
                // representing the visual center to align with canvas center.
                // Defaults to 0.5 (image geometric center) until computed.
                this.logoAnchorYNorm = 0.5;
                
                this.init();
            }
            
            init() {
                this.setupEventListeners();
                this.setupCanvas();
                this.setupCoreStyleSelection();
            }

            // Ensure we have a reliable aspect ratio for the logo image, including SVGs without intrinsic size
            async ensureLogoAspectRatio() {
                try {
                    if (this.logoAspectRatio && isFinite(this.logoAspectRatio) && this.logoAspectRatio > 0) return this.logoAspectRatio;

                    // Prefer naturalWidth/naturalHeight when available
                    const nw = this.logoImage && (this.logoImage.naturalWidth || this.logoImage.width);
                    const nh = this.logoImage && (this.logoImage.naturalHeight || this.logoImage.height);
                    if (nw && nh) {
                        this.logoAspectRatio = nw / nh;
                        // Try pixel-based refinement if SVG
                        if (this.logoImage.src && this.logoImage.src.toLowerCase().endsWith('.svg')) {
                            const pxRatio = this.computeLogoAspectRatioFromPixels(nw, nh);
                            if (pxRatio && isFinite(pxRatio) && pxRatio > 0) this.logoAspectRatio = pxRatio;
                        }
                        return this.logoAspectRatio;
                    }

                    // If it's an SVG, fetch and parse viewBox or width/height
                    const src = (this.logoImage && this.logoImage.src) || '';
                    if (src.toLowerCase().endsWith('.svg')) {
                        const res = await fetch(src);
                        const text = await res.text();
                        const viewBoxMatch = text.match(/viewBox\s*=\s*"([^"]+)"/i);
                        if (viewBoxMatch) {
                            const parts = viewBoxMatch[1].trim().split(/[\s,]+/).map(Number);
                            if (parts.length === 4) {
                                const vbW = parts[2];
                                const vbH = parts[3];
                                if (vbW > 0 && vbH > 0) {
                                    this.logoAspectRatio = vbW / vbH;
                                    // Pixel-based refinement
                                    const pxRatio = this.computeLogoAspectRatioFromPixels(vbW, vbH);
                                    if (pxRatio && isFinite(pxRatio) && pxRatio > 0) this.logoAspectRatio = pxRatio;
                                    return this.logoAspectRatio;
                                }
                            }
                        }
                        // Fallback to width/height attributes in the SVG
                        const widthMatch = text.match(/\bwidth\s*=\s*"([^"]+)"/i);
                        const heightMatch = text.match(/\bheight\s*=\s*"([^"]+)"/i);
                        const parseLen = (v) => {
                            if (!v) return NaN;
                            const num = parseFloat(v);
                            return isFinite(num) ? num : NaN;
                        };
                        const wAttr = parseLen(widthMatch && widthMatch[1]);
                        const hAttr = parseLen(heightMatch && heightMatch[1]);
                        if (wAttr > 0 && hAttr > 0) {
                            this.logoAspectRatio = wAttr / hAttr;
                            const pxRatio = this.computeLogoAspectRatioFromPixels(wAttr, hAttr);
                            if (pxRatio && isFinite(pxRatio) && pxRatio > 0) this.logoAspectRatio = pxRatio;
                            return this.logoAspectRatio;
                        }
                    }

                    // Last resort: assume 1:1 to avoid NaNs
                    this.logoAspectRatio = 1;
                    return this.logoAspectRatio;
                } catch (_) {
                    this.logoAspectRatio = 1;
                    return this.logoAspectRatio;
                }
            }

            // Compute aspect ratio based on visible non-transparent pixels to avoid metadata issues on mobile SVG
            computeLogoAspectRatioFromPixels(refW, refH) {
                try {
                    if (!this.logoImage || !this.logoImage.complete) return null;
                    // Choose a reasonable raster size for analysis
                    const targetW = Math.max(300, Math.min(800, refW || this.logoImage.width || 600));
                    const targetH = Math.max(150, Math.min(800, refH || this.logoImage.height || 300));
                    const off = document.createElement('canvas');
                    off.width = targetW;
                    off.height = targetH;
                    const ctx = off.getContext('2d');
                    ctx.clearRect(0, 0, targetW, targetH);
                    ctx.drawImage(this.logoImage, 0, 0, targetW, targetH);
                    const { data, width, height } = ctx.getImageData(0, 0, targetW, targetH);
                    const alphaThreshold = 16;
                    let minX = width, maxX = -1, minY = height, maxY = -1;
                    for (let y = 0; y < height; y++) {
                        for (let x = 0; x < width; x++) {
                            const a = data[(y * width + x) * 4 + 3];
                            if (a > alphaThreshold) {
                                if (x < minX) minX = x;
                                if (x > maxX) maxX = x;
                                if (y < minY) minY = y;
                                if (y > maxY) maxY = y;
                            }
                        }
                    }
                    if (maxX <= minX || maxY <= minY) return null;
                    const bw = (maxX - minX + 1);
                    const bh = (maxY - minY + 1);
                    const ratio = bw / bh;
                    this.logoAspectRatioPixels = ratio;
                    return ratio;
                } catch (_) {
                    return null;
                }
            }

            // Rasterize the logo (SVG or other) to a bitmap for stable drawImage rendering on mobile
            async rasterizeLogoBitmap() {
                try {
                    if (!this.logoImage || !this.logoImage.complete) return;
                    await this.ensureLogoAspectRatio();
                    const targetW = 4096;
                    const targetH = Math.max(1, Math.round(targetW / (this.logoAspectRatio || 1)));
                    const off = document.createElement('canvas');
                    off.width = targetW;
                    off.height = targetH;
                    const ctx = off.getContext('2d');
                    ctx.imageSmoothingEnabled = true;
                    ctx.imageSmoothingQuality = 'high';
                    ctx.clearRect(0, 0, targetW, targetH);
                    ctx.drawImage(this.logoImage, 0, 0, targetW, targetH);
                    let dataUrl;
                    try {
                        // Primary path: read from canvas (will throw if tainted)
                        dataUrl = off.toDataURL('image/png');
                    } catch (taintErr) {
                        // If tainted (e.g., SVG loaded in a way that taints canvas), try sanitizing by reloading SVG as a data URL
                        console.warn('Logo rasterization tainted; attempting SVG sanitize reload:', taintErr.message);
                        try {
                            const src = this.logoImage.src || '/dashboard/newcorelogo.svg';
                            let svgText = null;
                            // Prefer to fetch the original SVG text (same-origin)
                            try {
                                const resp = await fetch(src);
                                if (resp.ok) {
                                    svgText = await resp.text();
                                }
                            } catch (_) { /* ignore */ }
                            // If fetch failed and the src looks like a relative corelogo path, try that directly
                            if (!svgText && !/^data:/i.test(src)) {
                                try {
                                    const resp2 = await fetch('/dashboard/newcorelogo.svg');
                                    if (resp2.ok) svgText = await resp2.text();
                                } catch (_) { /* ignore */ }
                            }
                            if (svgText) {
                                const safeUrl = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svgText);
                                const tmpImg = new Image();
                                await new Promise((resolve, reject) => { tmpImg.onload = resolve; tmpImg.onerror = reject; tmpImg.src = safeUrl; });
                                // Draw sanitized image and read again
                                ctx.clearRect(0, 0, targetW, targetH);
                                ctx.drawImage(tmpImg, 0, 0, targetW, targetH);
                                dataUrl = off.toDataURL('image/png');
                            }
                        } catch (sanitizeErr) {
                            console.warn('SVG sanitize reload failed:', sanitizeErr);
                        }
                    }
                    if (!dataUrl) {
                        // As a final fallback, leave bitmap null; caller may draw SVG directly (with possible taint)
                        this.logoBitmap = null;
                        return;
                    }
                    const img = new Image();
                    await new Promise((resolve, reject) => { img.onload = resolve; img.onerror = reject; img.src = dataUrl; });
                    this.logoBitmap = img;
                } catch (e) {
                    console.warn('rasterizeLogoBitmap failed; fallback to SVG draw', e);
                    this.logoBitmap = null;
                }
            }
            
            setupEventListeners() {
                // Upload
                this.uploadMediaBtn.addEventListener('click', () => this.editorMediaInput.click());
                this.uploadPlaceholder.addEventListener('click', () => this.editorMediaInput.click());
                this.editorMediaInput.addEventListener('change', (e) => this.handleMediaUpload(e));
                
                // Drag & Drop for upload placeholder
                this.uploadPlaceholder.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    this.uploadPlaceholder.style.borderColor = 'var(--core-cyan)';
                    this.uploadPlaceholder.style.background = 'rgba(0, 255, 255, 0.05)';
                });
                
                this.uploadPlaceholder.addEventListener('dragleave', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    this.uploadPlaceholder.style.borderColor = 'rgba(0, 153, 255, 0.3)';
                    this.uploadPlaceholder.style.background = 'rgba(0, 25, 40, 0.2)';
                });
                
                this.uploadPlaceholder.addEventListener('drop', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    this.uploadPlaceholder.style.borderColor = 'rgba(0, 153, 255, 0.3)';
                    this.uploadPlaceholder.style.background = 'rgba(0, 25, 40, 0.2)';
                    
                    const files = e.dataTransfer.files;
                    if (files.length > 0) {
                        const file = files[0];
                        if (file.type.startsWith('image/')) {
                            // Trigger the same upload handler
                            const fakeEvent = { target: { files: [file] } };
                            this.handleMediaUpload(fakeEvent);
                        }
                    }
                });
                
                // Clear
                this.clearCanvasBtn.addEventListener('click', () => this.clearCanvas());
                
                // Logo
                this.addLogoBtn.addEventListener('click', () => this.addLogo());
                this.removeLogoBtn.addEventListener('click', () => this.removeLogo());
                this.centerLogoBtn.addEventListener('click', () => this.centerLogo());
                
                // Sliders - with aggressive debouncing for smooth performance
                if (this.logoSizeSlider && this.logoSizeValue) {
                    this.logoSizeSlider.addEventListener('input', (e) => {
                        this.logoSizeValue.textContent = e.target.value;
                        if (this.logo) {
                            const newWidth = parseInt(e.target.value);
                            const newHeight = newWidth / (this.logoAspectRatio || 1);
                            this.logo.width = newWidth;
                            this.logo.height = newHeight;
                            this.debouncedRender();
                        }
                    });
                } else {
                    console.error('Logo size slider or value element not found');
                }
                
                if (this.logoOpacitySlider && this.logoOpacityValue) {
                    this.logoOpacitySlider.addEventListener('input', (e) => {
                        this.logoOpacityValue.textContent = e.target.value + '%';
                        if (this.logo) {
                            this.logo.opacity = parseInt(e.target.value) / 100;
                            this.debouncedRender();
                        }
                    });
                } else {
                    console.error('Logo opacity slider or value element not found');
                }
                
                // Color picker (with aggressive debouncing due to expensive color processing)
                if (this.logoColorPicker && this.logoColorValue) {
                    let lastColorUpdate = 0;
                    const colorUpdateInterval = 100; // Update max 10 times per second
                    
                    this.logoColorPicker.addEventListener('input', (e) => {
                        const color = e.target.value;
                        this.logoColorValue.textContent = color.toUpperCase();
                        
                        if (this.logo) {
                            this.logo.color = color;
                            
                            // Throttle expensive color processing
                            const now = Date.now();
                            if (now - lastColorUpdate >= colorUpdateInterval) {
                                lastColorUpdate = now;
                                // Invalidate cache to force reprocessing
                                this.coloredLogoBitmap = null;
                                this.debouncedRender();
                            } else {
                                // Still update but defer processing
                                if (this._colorTimeout) clearTimeout(this._colorTimeout);
                                this._colorTimeout = setTimeout(() => {
                                    this.coloredLogoBitmap = null;
                                    lastColorUpdate = Date.now();
                                    this.render();
                                }, colorUpdateInterval);
                            }
                        }
                    });
                } else {
                    console.error('Logo color picker or value element not found');
                }
                
                // Subject Core buttons
                const subjectBtns = document.querySelectorAll('.subject-btn');
                subjectBtns.forEach(btn => {
                    btn.addEventListener('click', () => {
                        // Toggle selection
                        if (btn.classList.contains('selected')) {
                            btn.classList.remove('selected');
                            this.logoSubject = null;
                        } else {
                            subjectBtns.forEach(b => b.classList.remove('selected'));
                            btn.classList.add('selected');
                            this.logoSubject = btn.dataset.subject;
                        }
                        this.render();
                    });
                });
                
                // Export
                this.exportBtn.addEventListener('click', () => this.exportCanvas());
                
                // Canvas drag - Mouse events
                this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.canvas.addEventListener('mouseup', () => this.handleMouseUp());
                this.canvas.addEventListener('mouseleave', () => this.handleMouseUp());
                
                // Canvas drag - Touch events for mobile
                this.canvas.addEventListener('touchstart', (e) => this.handleTouchStart(e));
                this.canvas.addEventListener('touchmove', (e) => this.handleTouchMove(e));
                this.canvas.addEventListener('touchend', () => this.handleMouseUp());
                this.canvas.addEventListener('touchcancel', () => this.handleMouseUp());
                
                // Window resize
                window.addEventListener('resize', () => this.setupCanvas());
            }
            
            setupCanvas() {
                const rect = this.canvasWrapper.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;
                
                const containerWidth = rect.width;
                const containerHeight = rect.height;
                
                this.canvas.width = containerWidth * dpr;
                this.canvas.height = containerHeight * dpr;
                
                this.canvas.style.width = containerWidth + 'px';
                this.canvas.style.height = containerHeight + 'px';
                
                this.ctx.scale(dpr, dpr);
                
                this.canvasDisplayWidth = containerWidth;
                this.canvasDisplayHeight = containerHeight;
                
                if (this.currentMedia) {
                    this.render();
                }
            }
            
            setupCoreStyleSelection() {
                const toggleBtn = document.getElementById('styleToggleBtn');
                const dropdown = document.getElementById('styleDropdown');
                const applyBtn = document.getElementById('applyStyleBtn');
                const selectedStyleName = document.getElementById('selectedStyleName');
                const styleOptions = document.querySelectorAll('.core-style-option');
                
                // Move dropdown to body to avoid overflow issues
                document.body.appendChild(dropdown);
                
                let currentSelectedStyle = null;
                let currentSelectedStyleName = null;
                
                // Toggle dropdown
                toggleBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const isOpen = dropdown.style.display === 'block';
                    
                    if (isOpen) {
                        dropdown.style.display = 'none';
                        toggleBtn.classList.remove('open');
                    } else {
                        // Position dropdown below button
                        const rect = toggleBtn.getBoundingClientRect();
                        dropdown.style.top = `${rect.bottom + 4}px`;
                        dropdown.style.left = `${rect.left}px`;
                        dropdown.style.width = `${rect.width}px`;
                        dropdown.style.display = 'block';
                        toggleBtn.classList.add('open');
                        
                        console.log('Dropdown opened:', {
                            top: dropdown.style.top,
                            left: dropdown.style.left,
                            width: dropdown.style.width,
                            display: dropdown.style.display,
                            options: styleOptions.length
                        });
                    }
                });
                
                // Close dropdown when clicking outside
                document.addEventListener('click', (e) => {
                    if (!toggleBtn.contains(e.target) && !dropdown.contains(e.target)) {
                        dropdown.style.display = 'none';
                        toggleBtn.classList.remove('open');
                    }
                });
                
                // Handle option selection
                styleOptions.forEach(option => {
                    option.addEventListener('click', () => {
                        if (!this.currentMedia) {
                            alert('Please upload an image first');
                            return;
                        }
                        
                        // Remove selected from all
                        styleOptions.forEach(opt => opt.classList.remove('selected'));
                        // Add selected to clicked
                        option.classList.add('selected');
                        
                        currentSelectedStyle = option.getAttribute('data-style');
                        currentSelectedStyleName = option.textContent;
                        
                        // Update button text
                        selectedStyleName.textContent = currentSelectedStyleName;
                        
                        // Show apply button
                        applyBtn.style.display = 'block';
                        
                        // Close dropdown
                        dropdown.style.display = 'none';
                        toggleBtn.classList.remove('open');
                    });
                });
                
                // Apply style transformation
                applyBtn.addEventListener('click', async () => {
                    if (!currentSelectedStyle) return;
                    
                    // Show loading
                    const originalText = applyBtn.textContent;
                    applyBtn.textContent = 'Processing...';
                    applyBtn.disabled = true;
                    
                    try {
                        await this.applyStyleTransform(currentSelectedStyle, currentSelectedStyleName);
                    } catch (error) {
                        console.error('Style transform error:', error);
                        alert(`Error applying ${currentSelectedStyleName} style: ${error.message}`);
                    } finally {
                        applyBtn.textContent = originalText;
                        applyBtn.disabled = false;
                    }
                });
            }
            
            async applyStyleTransform(style, styleName) {
                // Get current frame as blob
                const blob = await new Promise(resolve => {
                    this.canvas.toBlob(resolve, 'image/png');
                });
                
                // Define style prompts
                const stylePrompts = {
                    'cybercore': 'transform this image into CyberCore style - maintain the original composition and subject, preserving the original color palette and lighting. infuse the scene with a futuristic, cyberpunk-inspired atmosphere that enhances what\'s already there rather than replacing it. add glowing circuitry patterns, digital data streams, holographic overlays, and faint light reflections across metallic or reflective surfaces. subtly integrate faint, glowing infinity symbols drifting in the background or reflected on surfaces - they should feel woven into the scene\'s energy, like repeating loops of light data, not overt logos. include soft ambient fog illuminated by holographic light sources and minimal lens flare. everything should pulse gently with digital life while preserving the original emotional tone and structure. generate as a 1x1 image ratio.',
                    'dreamcore': 'transform this image into DreamCore style - maintain the original composition, subject, and color palette, but soften the atmosphere into something surreal, ethereal, and emotionally immersive. add hazy dream-like fog, soft depth blur, faint glowing particles drifting through the air, and gentle light leaks that feel nostalgic or otherworldly. subtly integrate faint, glowing infinity symbols within the scene\'s haze or reflections - they should appear as part of the dream\'s flow, repeating softly like echoes of thought. preserve the emotional tone of the original, but make it feel suspended between memory and imagination. generate as a 1x1 image ratio.',
                    'weirdcore': 'transform this image into WeirdCore style - keep the same subject and colors, but make the world feel wrong. twist the perspective slightly, bend edges, and shift focus so the space doesn\'t add up. introduce faint VHS static, data-moshing, color banding, and chromatic bleeding. let the lighting flicker or hum. repeat or mirror small details where they shouldn\'t be - a doorway twice, an eye misaligned, a clock missing hands. add soft grain and low hum haze. weave in a few glowing infinity symbols that appear broken or half-rendered, flickering between frames as if the scene is trying to remember itself. the feeling should be nostalgic, uncanny, and slightly anxious, like you\'re seeing a memory through a malfunctioning lens. generate as a 1x1 image ratio.',
                    'vaporcore': 'transform this image into VaporwaveCore style - maintain the original composition and subject, but reimagine the world with nostalgic digital surrealism. overlay faint retro-futuristic textures, greek statues, gradient skies, palm trees, and chrome reflections subtly within the scene\'s depth. add gentle scanlines, lo-fi pixel noise, and soft neon glow reminiscent of 80s tech and early internet aesthetics. use hues that echo fading technology and consumer memory - pastel pinks, cyans, purples, and warm magentas blending softly into one another. subtly integrate glowing infinity symbols hidden in reflections or floating lightly in the haze - they should feel like echoes of a forgotten system looping endlessly. add light fog, soft VHS bleed, and ambient lighting that feels dreamlike yet artificial. the atmosphere should feel nostalgic, synthetic, and peacefully detached, like the memory of a world that never existed. generate as a 1x1 image ratio.',
                    'anime': 'transform this image into AnimeCore style - maintain the original composition, subject, and color palette, but completely reinterpret it as if it were drawn and colored by a high-quality anime artist. use smooth, precise linework, vibrant yet balanced colors, and detailed cel-style shading with soft, controlled gradients. define facial features and edges with clean ink outlines, and enhance lighting to feel emotional and cinematic - bright highlights, deep shadows, and subtle bloom around reflective areas. keep proportions and structure identical to the original, but express every surface with crisp anime-style texture and tone depth. integrate multiple faint, glowing infinity symbols throughout the environment - appearing within light flares, sky gradients, reflections, particle trails, or background details - so they feel like natural repeating motifs woven into the world\'s design. the final image should feel like a frame from a beautifully animated film, full of emotion, motion, and crafted precision. generate as a 1x1 image ratio.',
                    'manga': 'transform this image into MangaCore style - maintain the original composition and subject, but reinterpret it as a high-quality black-and-white manga illustration. use precise, confident ink linework with rich tonal contrast between pure blacks, whites, and textured halftones. apply cross-hatching, screen-tone shading, and speed-line details to convey depth, motion, and atmosphere. preserve the emotional weight and framing of the original, but express it entirely through monochrome drawing techniques. integrate multiple faint infinity symbols as recurring visual motifs - appearing as glowing white outlines, stylized ink emblems, or subtle patterns within the background - ensuring they feel like natural parts of the world\'s design. the final image should look like a single, striking manga panel - expressive, clean, and dynamic. generate as a 1x1 image ratio.',
                    'cottage': 'transform this image into CottageCore style - maintain the original composition and subject, but reimagine the scene through a peaceful, natural, countryside aesthetic. emphasize soft natural lighting, warm gentle shadows, and organic textures like linen, wood, and wildflowers. enrich the environment with details of nature - blooming gardens, grass, trees, sunlight filtering through leaves, or rustic decor elements like woven baskets, candles, and books. enhance the color palette subtly to reflect warmth and serenity: soft greens, warm creams, muted browns, and gentle golden light. integrate multiple faint, glowing infinity symbols woven naturally into the world - appearing in flower arrangements, light reflections, fabric patterns, or drifting pollen - as if the symbol itself were part of nature\'s design. the overall feeling should be calm, nostalgic, and human - a quiet escape into a simpler, more harmonious world. generate as a 1x1 image ratio.',
                    'hopecore': 'transform this image into HopeCore style - maintain the original composition and subject, but reinterpret the world to express optimism, connection, and renewal. infuse the scene with a sense of warmth and humanity - subtle golden light, gentle depth, and balanced contrast that brings out emotion without exaggeration. highlight wholesome or uplifting undertones in the image: moments that suggest kindness, reunion, perseverance, or small triumphs. evoke a quiet confidence that things can get better, even in stillness. integrate multiple faint, glowing infinity symbols as part of the environment - appearing softly in reflections, rays of light, patterns in the background, or particles in the air - symbolizing continuity, healing, and hope that never fades. preserve the natural color palette but gently enhance clarity and warmth to make the image feel alive, sincere, and forward-looking. the final result should radiate positivity and compassion - a visual countermeasure to fear and negativity that celebrates life, connection, and the persistence of good. generate as a 1x1 image ratio.',
                    'royal': 'transform this image into RoyalCore style - maintain the original composition and subject, but reinterpret it with an aura of elegance, power, and timeless royalty. enhance the scene with refined textures such as velvet, silk, gold, or polished stone while preserving realism. introduce subtle regal elements like ornate crowns, embroidered fabrics, jewelry, or decorative architectural details that feel naturally part of the world, not added props. use controlled lighting - soft highlights, gentle shadows, and golden reflections - to emphasize grace and presence. integrate multiple faint, glowing infinity symbols throughout the environment - appearing as patterns in embroidery, reflections in metal, or motifs within the background - symbolizing eternal strength and legacy. keep the colors balanced, rich, and dignified without oversaturation. the final image should radiate nobility, confidence, and quiet power - as if the subject were born to rule their world. generate as a 1x1 image ratio.',
                    'moneycore': 'transform this image into MoneyCore style - maintain the original composition and subject, but reinterpret it through the visual language of wealth, confidence, and success. enhance the world with refined materials like tailored fabric, glass, polished metal, marble, and soft ambient lighting that evokes luxury without exaggeration. dress subjects in sharp, modern business attire - suits, watches, subtle accessories - emphasizing professionalism and composure. depict the subject counting money in their hands or on a desk, with bills designed elegantly - some featuring subtle glowing infinity symbols as part of their design, representing limitless growth and prosperity. enrich the environment with financial or executive cues such as office skylines, elegant desks, or faint currency textures integrated into surfaces or lighting reflections. integrate multiple faint, glowing infinity symbols throughout the scene - appearing in reflections, jewelry, or ambient highlights - to reinforce the sense of infinite value. preserve realism and composition, keeping the tone sophisticated, powerful, and aspirational. the final image should radiate discipline, control, and purpose - the calm confidence of someone who built their own empire. generate as a 1x1 image ratio.',
                    'frutiger': 'transform this image into Frutiger Aero style - maintain the original composition and subject, but reinterpret it through the bright, glossy, tech-optimistic look of the mid-2000s. emphasize clean gradients, glassy transparency, soft reflections, and rounded shapes inspired by early web 2.0 and Windows XP design. infuse the environment with smooth blues, vibrant greens, and gentle highlights that suggest clarity and motion. surfaces should feel luminous and fluid - like light passing through glass and air. integrate multiple faint, glowing infinity symbols throughout the scene - appearing as reflections on glass, subtle interface icons, or soft light streaks - representing perpetual connection and modern harmony. avoid haze or heavy contrast; keep the world clear, glossy, and precise. the final image should radiate freshness, innovation, and calm digital optimism - as if it belongs in an era when the internet still felt new and limitless. generate as a 1x1 image ratio.',
                    'ravecore': 'transform this image into Hardstyle / RaveCore style - maintain the original composition and subject, but electrify the atmosphere with high-energy rave intensity. add strobe-lit lighting, pulsing neon beams, and laser trails that cut through subtle haze. emphasize dynamic contrast with deep blacks, ultraviolet purples, acid greens, and hot pink highlights, creating the look of motion frozen mid-beat. introduce metallic reflections, lens glares, and faint digital distortion that convey rhythm and sound. integrate multiple glowing infinity symbols into the scene - projected onto walls, hovering in laser light, or repeating as light patterns across smoke - representing endless motion and euphoria. preserve the subject\'s realism but amplify the kinetic vibe so the whole scene feels alive with bass, color, and unstoppable energy. generate as a 1x1 image ratio.',
                    'pixelcore': 'transform this image into PixelCore style - maintain the original composition and subject, but reinterpret it through a pixel-art aesthetic that feels crisp, nostalgic, and digital. reconstruct the world with visible pixels, clear outlines, and simplified color shading that evokes classic game or early computer graphics. preserve detail where necessary, but express it through blocky structure and pixel-based texture instead of smooth gradients. introduce faint screen artifacts such as scanlines, CRT glow, or limited color palettes that give it retro authenticity. integrate multiple glowing infinity symbols throughout the scene - appearing as pixel icons, holographic glyphs, or repeating light patterns - representing infinite digital connection. keep everything balanced, vivid, and structured; the final image should feel like a living 16-bit universe rendered in modern clarity. generate as a 1x1 image ratio.',
                    'alonecore': 'transform this image into AloneCore style - maintain the original composition and subject, but reinterpret it to express solitude, stillness, and quiet self-awareness. slightly reduce saturation and contrast to evoke emotional calm, using soft natural light and open negative space to emphasize isolation without sadness. if a person is present, depict them with a thoughtful or distant demeanor, surrounded by quiet emptiness that feels peaceful rather than painful. integrate multiple faint, glowing infinity symbols into the environment - appearing as subtle reflections, distant lights, or soft patterns in the background - symbolizing inner connection and continuity even in solitude. avoid heavy haze or distortion; keep everything grounded, quiet, and sincere. the final image should feel introspective, calm, and human - the moment when being alone becomes understanding. generate as a 1x1 image ratio.',
                    'raptorcore': 'Transform the subject of the provided image into their RaptorCore form - a powerful, intelligent velociraptor version of themselves - while keeping the exact same composition, pose, camera angle, lighting, and background as the original image. The transformation must look natural and seamless, as if revealing the subject\'s primal essence rather than replacing them. Preserve all defining visual traits of the original subject - including skin tone, hairstyle, clothing, posture, and recognizable details - and reinterpret them through a raptor-like anatomy with realistic textures, musculature, and facial structure. The raptor version should retain the subject\'s personality, expression, and energy. Add sleek scales, defined musculature, and sharp, aware eyes, with dynamic lighting that conveys strength and sentience. Integrate faint, glowing infinity symbols subtly throughout the environment and character - appearing as markings on scales, reflections in the eyes, or faint energy traces in the air - symbolizing evolution, instinct, and infinite adaptability. The overall tone should be cinematic, powerful, confident, and vivid, showing the fusion of human identity and ancient strength. Aspect ratio: 1x1. Instruction: Maintain every original element of the scene except the biological transformation itself.',
                    'pumpcore': 'transform this image into PumpFunCore style ‚Äî maintain the exact structure, positioning, and composition of the original image so that the subject\'s form, balance, and identity remain fully intact. reinterpret the world through a smooth, futuristic, medicine-inspired aesthetic infused with white, mint green, and soft teal tones that radiate calm digital energy. integrate glossy pharmaceutical medicine throughout the environment (each medicine must be a perfect elongated oval shape ‚Äî smooth, symmetrical pill form like standard medicine with rounded ends and clean geometric proportions, no distortions or irregular shapes) ‚Äî some floating gently in the air, others reflected softly on nearby surfaces ‚Äî each glowing with subtle light refractions that create a surreal yet pristine atmosphere. add multiple faint, glowing ‚àû symbols (the mathematical infinity symbol: a smooth, continuous loop forming two symmetrical circles connected at the center, like a perfectly balanced horizontal figure-8 or lemniscate curve with no breaks or distortions) naturally floating through the scene and integrated into reflections, medicine trails, and light patterns ‚Äî each symbol must maintain perfect symmetry with two equal-sized loops meeting smoothly in the middle ‚Äî they should feel woven into the digital rhythm of the environment, not overlaid. use cool ambient lighting with precise gradients and clean reflections, as if the entire scene hums with quiet, clinical vitality. fade the background between matte black, dark green, and mint glow to build depth and focus while preserving the original framing. add circular beam glows and holographic halos that highlight contours and light reflections with studio-like precision. each medicine must follow the perfect pharmaceutical form with color scheme: one half pure white (#ffffff) and the other half bright mint green (#60cc8a), divided cleanly at the middle with a smooth transition line, glowing softly with balanced reflection and tone. the final image should feel sleek, confident, and refined ‚Äî preserving the strength and realism of the original while enhancing it with futuristic calm, minimalism, and bioluminescent energy. generate as a 1√ó1 image ratio.',
                    'clowncore': 'transform this image into ClownCore style - maintain the original composition and subject, but reinterpret it through a chaotic, surreal, and expressive clown aesthetic. enhance the world with vibrant color contrasts, mismatched patterns, and eccentric textures like sequins, satin, and face paint. give the subject clown-like features while preserving their recognizable identity - expressive makeup, exaggerated emotions, or playful accessories that feel natural within the scene rather than costume-like. incorporate absurd yet stylish details such as striped fabric, polka dots, or colorful lighting that hint at both humor and existential depth. integrate multiple faint, glowing infinity symbols throughout - appearing in makeup reflections, balloon surfaces, neon lights, or background motifs - representing the endless loop between joy and madness. avoid horror tones; keep it artful, bold, and self-aware. the final image should feel bizarrely beautiful - a celebration of chaos, humor, and humanity existing all at once. generate as a 1x1 image ratio.',
                    'auracore': 'transform this image into AuraCore style - maintain the original composition and subject, but reinterpret it through a glowing, digital-spiritual aesthetic that radiates energy and meaning. illuminate the world with soft glowing light in the color #a6e244, creating an aura that feels alive and infinite. add a fine layer of film grain and glow, balancing clarity with subtle distortion to evoke otherworldly calm. integrate multiple glowing infinity symbols throughout the image - appearing as energy trails, reflections, light rings, or background motifs - representing the infinite bond between self and aura. highlight shapes and silhouettes with smooth gradients, faint bloom, and clean geometry, blending minimalism with cosmic warmth. preserve the image\'s tone and palette but amplify it with luminous accents in #a6e244 that feel pure and intentional. the final result should radiate balance, energy, and transcendence - every inch glowing with aura. generate as a 1x1 image ratio.',
                    'spacecore': 'transform this image into SpaceCore style - maintain the original composition and subject, but reinterpret it through a vast, cinematic, and galactic aesthetic. immerse the scene in deep cosmic color and glowing starlight - vibrant blues, purples, and greens blending into infinite darkness. fill the background with planets, nebulae, asteroids, and glowing particles that convey depth and motion. illuminate the subject with soft, directional cosmic light that feels otherworldly but balanced. integrate multiple glowing infinity symbols throughout the environment - appearing as constellations, orbit rings, distant light patterns, or energy trails - symbolizing infinite connection across space and time. add subtle lens flares, particle dust, and light scattering to create realism and scale. the final image should feel boundless, luminous, and transcendent - a universe alive with infinite motion and meaning. generate as a 1x1 image ratio.',
                    'catcore': 'transform this image into CatCore style - maintain the original composition and subject, but reinterpret them as a cat version of themselves while preserving all defining features. keep their skin tone, hair color, clothing, accessories, and recognizable details fully intact, seamlessly adapted into feline anatomy. the result should feel natural and expressive, as if this transformation reveals their true calm, curious essence rather than replaces them. emphasize soft fur texture, expressive eyes, and subtle feline grace, keeping the pose and emotion exactly the same. integrate multiple faint, glowing infinity symbols within the environment and design - appearing as reflections in eyes, markings in fur, or ambient background glows - symbolizing instinct, awareness, and infinite curiosity. the final image should radiate intelligence, balance, and quiet confidence - the essence of Core energy through feline form. generate as a 1x1 image ratio.',
                    'dogcore': 'transform this image into DogCore style - keep the image exactly the same in composition, lighting, and clarity, but reinterpret the subject as a dog version of themselves. preserve every defining feature - their skin tone, hair color, clothing, accessories, and recognizable details - seamlessly adapted into realistic canine anatomy. the transformation should feel completely natural, as if they have always been this way. emphasize lifelike fur texture, expressive eyes, and authentic emotion, matching the original expression and posture perfectly. integrate multiple faint, glowing infinity symbols subtly throughout - appearing as reflections in eyes, markings in fur, or background light patterns - symbolizing loyalty, companionship, and infinite devotion. do not stylize, repaint, or blur anything; just transform the subject into their true dog form while keeping every other element identical. generate as a 1x1 image ratio.'
                };
                
                const prompt = stylePrompts[style] || `Transform this image into ${styleName} aesthetic style`;
                
                // Send to AI API
                const formData = new FormData();
                formData.append('image', blob, 'current-frame.png');
                formData.append('style', style);
                formData.append('prompt', prompt);
                
                const response = await fetch('/api/apply-style', {
                    method: 'POST',
                    body: formData
                });
                
                if (!response.ok) {
                    let msg = `API error: ${response.status}`;
                    try {
                        const err = await response.json();
                        if (err?.code || err?.error || err?.details) {
                            msg += ` - ${[err.code, err.error, err.details].filter(Boolean).join(' | ')}`;
                        }
                    } catch {}
                    throw new Error(msg);
                }
                
                const result = await response.json();
                
                if (result.image) {
                    // Load transformed image
                    const transformedImg = new Image();
                    // crossOrigin nie jest potrzebny dla data URLs z base64
                    // transformedImg.crossOrigin = 'anonymous';
                    transformedImg.onload = () => {
                        this.currentMedia = transformedImg;
                        this.mediaType = 'image'; // Now it's an image
                        this.render();
                    };
                    transformedImg.src = `data:image/png;base64,${result.image}`;
                } else {
                    throw new Error(result.error || 'Style transformation failed');
                }
            }
            
            handleMediaUpload(e) {
                const file = e.target.files[0];
                if (!file) {
                    console.log('No file selected');
                    return;
                }
                
                console.log('File selected:', file.name, file.type, file.size);
                
                const fileType = file.type.split('/')[0];
                
                if (fileType === 'image') {
                    this.mediaType = 'image';
                    const img = new Image();
                    img.onload = () => {
                        console.log('Image loaded successfully:', img.width, 'x', img.height);
                        this.currentMedia = img;
                        this.showCanvas();
                    };
                    img.onerror = (err) => {
                        console.error('Image load error:', err);
                        alert('Failed to load image. Please try a different file.');
                    };
                    img.src = URL.createObjectURL(file);
                } else {
                    console.log('Unsupported file type:', file.type);
                    alert('Unsupported file type. Please upload an image.');
                }
            }
            
            showCanvas() {
                this.uploadPlaceholder.style.display = 'none';
                this.canvas.style.display = 'block';
                this.clearCanvasBtn.style.display = 'block';
                
                // Poka≈º kontrolki logo i style po wgraniu nowego zdjƒôcia
                this.logoControls.style.display = 'block';
                this.coreStyleControls.style.display = 'block';
                this.exportControls.style.display = 'block';
                
                // Enable all buttons
                this.addLogoBtn.disabled = false;
                this.styleToggleBtn.disabled = false;
                this.exportBtn.disabled = false;
                
                const exportNote = document.getElementById('exportNote');
                exportNote.textContent = 'Image will be exported as PNG';
                
                this.render();
            }
            
            // Debounced render for smooth slider/picker performance
            debouncedRender() {
                if (this._renderTimeout) {
                    cancelAnimationFrame(this._renderTimeout);
                }
                this._renderTimeout = requestAnimationFrame(() => {
                    this.render();
                    this._renderTimeout = null;
                });
            }
            
            render() {
                if (!this.currentMedia) return;
                
                this.ctx.clearRect(0, 0, this.canvasDisplayWidth, this.canvasDisplayHeight);
                
                // Draw media with contain fit - show full image without cropping
                const mediaAspect = (this.currentMedia.naturalWidth || this.currentMedia.width) / 
                    (this.currentMedia.naturalHeight || this.currentMedia.height);
                const canvasAspect = this.canvasDisplayWidth / this.canvasDisplayHeight;
                
                let drawWidth, drawHeight, offsetX, offsetY;
                
                // Contain fit - show entire image maintaining aspect ratio
                if (mediaAspect > canvasAspect) {
                    // Media is wider - fit to width
                    drawWidth = this.canvasDisplayWidth;
                    drawHeight = this.canvasDisplayWidth / mediaAspect;
                    offsetX = 0;
                    offsetY = (this.canvasDisplayHeight - drawHeight) / 2;
                } else {
                    // Media is taller - fit to height
                    drawHeight = this.canvasDisplayHeight;
                    drawWidth = this.canvasDisplayHeight * mediaAspect;
                    offsetX = (this.canvasDisplayWidth - drawWidth) / 2;
                    offsetY = 0;
                }
                
                this.ctx.drawImage(this.currentMedia, offsetX, offsetY, drawWidth, drawHeight);
                
                // Draw guide lines if dragging
                if (this.isDragging) {
                    this.ctx.strokeStyle = 'cyan';
                    this.ctx.lineWidth = 1;
                    this.ctx.setLineDash([5, 5]);
                    
                    const centerX = this.canvasDisplayWidth / 2;
                    const centerY = this.canvasDisplayHeight / 2;
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(centerX, 0);
                    this.ctx.lineTo(centerX, this.canvasDisplayHeight);
                    this.ctx.stroke();
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, centerY);
                    this.ctx.lineTo(this.canvasDisplayWidth, centerY);
                    this.ctx.stroke();
                    
                    this.ctx.setLineDash([]);
                }
                
                // Draw logo
                if (this.logo && this.logoImageLoaded && this.logoImage.complete) {
                    this.ctx.save();
                    this.ctx.globalAlpha = this.logo.opacity;
                    this.ctx.imageSmoothingEnabled = true;
                    this.ctx.imageSmoothingQuality = 'high';
                    
                    // Apply color tint if color is set
                    if (this.logo.color && this.logo.color !== '#00FFFF') {
                        // Check if we need to regenerate colored bitmap
                        if (!this.coloredLogoBitmap || this.lastLogoColor !== this.logo.color) {
                            // Convert hex color to RGB
                            const hex = this.logo.color.replace('#', '');
                            const r = parseInt(hex.substr(0, 2), 16);
                            const g = parseInt(hex.substr(2, 2), 16);
                            const b = parseInt(hex.substr(4, 2), 16);
                            
                            // Use high-res bitmap for coloring to maintain quality
                            const srcImg = this.logoBitmap || this.logoImage;
                            const sourceWidth = srcImg.naturalWidth || srcImg.width;
                            const sourceHeight = srcImg.naturalHeight || srcImg.height;
                            
                            // Create a temporary canvas at SOURCE resolution (high quality)
                            const tempCanvas = document.createElement('canvas');
                            tempCanvas.width = sourceWidth;
                            tempCanvas.height = sourceHeight;
                            const tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true });
                            
                            // Enable high-quality rendering
                            tempCtx.imageSmoothingEnabled = true;
                            tempCtx.imageSmoothingQuality = 'high';
                            
                            // Draw source image at full resolution
                            tempCtx.drawImage(srcImg, 0, 0, sourceWidth, sourceHeight);
                            
                            // Get image data and apply color tint
                            const imageData = tempCtx.getImageData(0, 0, sourceWidth, sourceHeight);
                            const data = imageData.data;
                            
                            for (let i = 0; i < data.length; i += 4) {
                                // Only tint non-transparent pixels
                                if (data[i + 3] > 0) {
                                    // Calculate brightness of original pixel
                                    const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3 / 255;
                                    // Apply new color while maintaining brightness
                                    data[i] = r * brightness;
                                    data[i + 1] = g * brightness;
                                    data[i + 2] = b * brightness;
                                }
                            }
                            
                            tempCtx.putImageData(imageData, 0, 0);
                            
                            // Cache the colored bitmap
                            this.coloredLogoBitmap = tempCanvas;
                            this.lastLogoColor = this.logo.color;
                        }
                        
                        // Draw the cached colored bitmap scaled to display size
                        this.ctx.drawImage(this.coloredLogoBitmap, this.logo.x, this.logo.y, this.logo.width, this.logo.height);
                    } else {
                        const srcImg = this.logoBitmap || this.logoImage;
                        this.ctx.drawImage(srcImg, this.logo.x, this.logo.y, this.logo.width, this.logo.height);
                    }
                    
                    // Draw subject text above logo if selected
                    if (this.logoSubject) {
                        this.ctx.save();
                        this.ctx.globalAlpha = this.logo.opacity;
                        
                        // Calculate font size based on logo width
                        const fontSize = Math.max(this.logo.width * 0.15, 20);
                        this.ctx.font = `bold ${fontSize}px "SF Pro Display", -apple-system, BlinkMacSystemFont, sans-serif`;
                        this.ctx.textAlign = 'center';
                        this.ctx.textBaseline = 'bottom';
                        
                        // Position text above logo with some padding
                        const textX = this.logo.x + this.logo.width / 2;
                        const textY = this.logo.y - (fontSize * 0.3);
                        
                        // Draw text with stroke for better visibility
                        this.ctx.strokeStyle = '#000000';
                        this.ctx.lineWidth = fontSize * 0.15;
                        this.ctx.strokeText(this.logoSubject, textX, textY);
                        
                        this.ctx.fillStyle = '#7FD957';
                        this.ctx.fillText(this.logoSubject, textX, textY);
                        
                        this.ctx.restore();
                    }
                    
                    this.ctx.restore();
                }
            }

            // Compute a better visual anchor for vertical centering based on the logo image content.
            // We try to detect the top line ("CORE") and center on it, ignoring the "BE RARE" line below.
            computeLogoAnchor() {
                if (!this.logoImage || !this.logoImage.complete) return;
                try {
                    const w = this.logoImage.naturalWidth || this.logoImage.width;
                    const h = this.logoImage.naturalHeight || this.logoImage.height;
                    if (!w || !h) return;

                    const off = document.createElement('canvas');
                    off.width = w;
                    off.height = h;
                    const octx = off.getContext('2d');
                    octx.drawImage(this.logoImage, 0, 0);
                    const img = octx.getImageData(0, 0, w, h);
                    const data = img.data;

                    const rowCounts = new Array(h).fill(0);
                    const rowCountsRight = new Array(h).fill(0);
                    const alphaThreshold = 32; // ignore very faint pixels/antialias
                    const rightStart = Math.floor(w * 0.65); // focus on the 'E' on the right
                    for (let y = 0; y < h; y++) {
                        let cnt = 0;
                        let cntRight = 0;
                        const rowStart = y * w * 4;
                        for (let x = 0; x < w; x++) {
                            const a = data[rowStart + x * 4 + 3];
                            if (a > alphaThreshold) {
                                cnt++;
                                if (x >= rightStart) cntRight++;
                            }
                        }
                        rowCounts[y] = cnt;
                        rowCountsRight[y] = cntRight;
                    }

                    // Find content top and bottom
                    const minRowCount = Math.max(1, Math.floor(w * 0.01));
                    let top = 0, bottom = h - 1;
                    while (top < h && rowCounts[top] <= minRowCount) top++;
                    while (bottom > top && rowCounts[bottom] <= minRowCount) bottom--;

                    // Default to full content center
                    let coreTop = top;
                    let coreBottom = bottom;

                    // Find gap between 'CORE' and 'BE RARE' using right-side counts to be robust
                    const searchStart = Math.floor(h * 0.20);
                    const searchEnd = Math.floor(h * 0.90);
                    let minVal = Number.MAX_SAFE_INTEGER;
                    let minIdx = -1;
                    let maxVal = 0;
                    for (let y = searchStart; y <= searchEnd; y++) {
                        const v = rowCountsRight[y];
                        if (v < minVal) { minVal = v; minIdx = y; }
                        if (v > maxVal) maxVal = v;
                    }
                    const valleyIsGap = minIdx > top + 5 && minIdx < bottom - 5 && minVal < Math.max(3, maxVal * 0.20);
                    if (valleyIsGap) {
                        coreBottom = minIdx; // top block ends at the gap
                    }

                    // Within CORE block, detect bars of 'E' using right-side counts
                    const smooth = (arr, k = 3) => {
                        const out = new Array(arr.length).fill(0);
                        for (let i = 0; i < arr.length; i++) {
                            let s = 0, c = 0;
                            for (let j = -k; j <= k; j++) {
                                const idx = i + j;
                                if (idx >= 0 && idx < arr.length) { s += arr[idx]; c++; }
                            }
                            out[i] = s / c;
                        }
                        return out;
                    };
                    const region = rowCountsRight.slice(coreTop, coreBottom + 1);
                    const sm = smooth(region, 2);
                    let regionMax = 0;
                    for (let v of sm) regionMax = Math.max(regionMax, v);
                    const peakThresh = Math.max(3, regionMax * 0.60);

                    // Group contiguous rows above threshold as bands
                    const bands = [];
                    let inBand = false, start = 0;
                    for (let i = 0; i < sm.length; i++) {
                        if (sm[i] >= peakThresh) {
                            if (!inBand) { inBand = true; start = i; }
                        } else if (inBand) {
                            inBand = false;
                            const end = i - 1;
                            bands.push({ start: start + coreTop, end: end + coreTop, center: (start + end) / 2 + coreTop });
                        }
                    }
                    if (inBand) {
                        const end = sm.length - 1;
                        bands.push({ start: start + coreTop, end: end + coreTop, center: (start + end) / 2 + coreTop });
                    }

                    // Choose the band whose center is closest to the middle of the CORE block (likely the middle bar of 'E')
                    let anchorY = (coreTop + coreBottom) / 2;
                    if (bands.length > 0) {
                        const coreMid = (coreTop + coreBottom) / 2;
                        let best = bands[0];
                        let bestDist = Math.abs(bands[0].center - coreMid);
                        for (let b of bands) {
                            const d = Math.abs(b.center - coreMid);
                            if (d < bestDist) { best = b; bestDist = d; }
                        }
                        anchorY = best.center;
                    }

                    // Normalized anchor position inside the image
                    this.logoAnchorYNorm = anchorY / h;
                } catch (e) {
                    console.warn('computeLogoAnchor failed:', e);
                    this.logoAnchorYNorm = 0.5;
                }
            }
            
            async addLogo() {
                if (this.logo) return; // already added
                // Ensure logo image exists
                if (!this.logoImage) {
                    this.logoImage = new Image();
                    // Nie u≈ºywamy crossOrigin dla lokalnych plik√≥w SVG
                    // this.logoImage.crossOrigin = 'anonymous';  
                    this.logoImage.onload = async () => {
                        this.logoImageLoaded = true;
                        this.computeLogoAnchor();
                        await this.ensureLogoAspectRatio();
                        // Rasterize SVG to bitmap to avoid mobile/iOS drawImage distortions
                        await this.rasterizeLogoBitmap();
                        const logoWidth = 200;
                        const logoHeight = logoWidth / (this.logoAspectRatio || 1);
                        this.logo = { x: 0, y: 0, width: logoWidth, height: logoHeight, opacity: 1, color: this.logoColor };
                        // Show controls now that logo is ready
                        this.removeLogoBtn.style.display = 'block';
                        this.centerLogoBtn.style.display = 'block';
                        this.logoSizeControl.style.display = 'block';
                        this.logoOpacityControl.style.display = 'block';
                        this.logoColorControl.style.display = 'block';
                        if (this.logoSizeSlider && this.logoSizeValue) {
                            this.logoSizeSlider.value = logoWidth;
                            this.logoSizeValue.textContent = logoWidth;
                        }
                        if (this.logoOpacitySlider && this.logoOpacityValue) {
                            this.logoOpacitySlider.value = 100;
                            this.logoOpacityValue.textContent = '100%';
                        }
                        if (this.logoColorPicker && this.logoColorValue) {
                            this.logoColorPicker.value = this.logoColor;
                            this.logoColorValue.textContent = this.logoColor.toUpperCase();
                        }
                        this.centerLogo();
                    };
                    this.logoImage.onerror = (error) => {
                        console.error('Failed to load logo image:', error);
                        console.log('Trying to load logo from:', this.logoImage.src);
                        alert('Failed to load logo. Please check if newcorelogo.svg exists in the same folder.');
                    };
                    // Load SVG as same-origin data URL to avoid any cross-origin taint
                    fetch('/dashboard/newcorelogo.svg')
                        .then(resp => resp.ok ? resp.text() : Promise.reject(new Error('HTTP ' + resp.status)))
                        .then(svgText => {
                            const dataUrl = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svgText);
                            this.logoImage.src = dataUrl;
                        })
                        .catch(() => {
                            // Fallback to direct path if fetch fails (e.g., older environments)
                            this.logoImage.src = '/dashboard/newcorelogo.svg';
                        });
                } else {
                    // If already instantiated image and possibly cached
                    if (this.logoImage.complete) {
                        await this.ensureLogoAspectRatio();
                        await this.rasterizeLogoBitmap();
                        const logoWidth = 200;
                        const logoHeight = logoWidth / (this.logoAspectRatio || 1);
                        this.logo = { x: 0, y: 0, width: logoWidth, height: logoHeight, opacity: 1, color: this.logoColor };
                        this.removeLogoBtn.style.display = 'block';
                        this.centerLogoBtn.style.display = 'block';
                        this.logoSizeControl.style.display = 'block';
                        this.logoOpacityControl.style.display = 'block';
                        this.logoColorControl.style.display = 'block';
                        if (this.logoSizeSlider && this.logoSizeValue) {
                            this.logoSizeSlider.value = logoWidth;
                            this.logoSizeValue.textContent = logoWidth;
                        }
                        if (this.logoOpacitySlider && this.logoOpacityValue) {
                            this.logoOpacitySlider.value = 100;
                            this.logoOpacityValue.textContent = '100%';
                        }
                        if (this.logoColorPicker && this.logoColorValue) {
                            this.logoColorPicker.value = this.logoColor;
                            this.logoColorValue.textContent = this.logoColor.toUpperCase();
                        }
                        this.centerLogo();
                    }
                }
            }
            
            removeLogo() {
                this.logo = null;
                this.logoSubject = null;
                this.removeLogoBtn.style.display = 'none';
                this.centerLogoBtn.style.display = 'none';
                this.logoSizeControl.style.display = 'none';
                this.logoOpacityControl.style.display = 'none';
                this.logoColorControl.style.display = 'none';
                this.render();
            }
            
            centerLogo() {
                if (this.logo) {
                    const targetX = (this.canvasDisplayWidth - this.logo.width) / 2;
                    // Geometric center vertically (no anchor/calibration)
                    const targetY = (this.canvasDisplayHeight - this.logo.height) / 2;
                    this.logo.x = targetX;
                    this.logo.y = targetY;
                    this.render();
                }
            }
            
            handleMouseDown(e) {
                if (!this.logo) return;
                
                const rect = this.canvas.getBoundingClientRect();
                const scaleX = this.canvasDisplayWidth / rect.width;
                const scaleY = this.canvasDisplayHeight / rect.height;
                const mouseX = (e.clientX - rect.left) * scaleX;
                const mouseY = (e.clientY - rect.top) * scaleY;
                
                if (mouseX >= this.logo.x && mouseX <= this.logo.x + this.logo.width &&
                    mouseY >= this.logo.y && mouseY <= this.logo.y + this.logo.height) {
                    this.isDragging = true;
                    this.dragOffset.x = mouseX - this.logo.x;
                    this.dragOffset.y = mouseY - this.logo.y;
                }
            }
            
            handleMouseMove(e) {
                if (!this.isDragging) return;
                
                const rect = this.canvas.getBoundingClientRect();
                const scaleX = this.canvasDisplayWidth / rect.width;
                const scaleY = this.canvasDisplayHeight / rect.height;
                const mouseX = (e.clientX - rect.left) * scaleX;
                const mouseY = (e.clientY - rect.top) * scaleY;
                
                let newX = mouseX - this.dragOffset.x;
                let newY = mouseY - this.dragOffset.y;
                
                // Allow partial off-canvas
                newX = Math.max(-this.logo.width + 50, Math.min(newX, this.canvasDisplayWidth - 50));
                newY = Math.max(-this.logo.height + 50, Math.min(newY, this.canvasDisplayHeight - 50));
                
                // Snap to geometric center
                const centerX = (this.canvasDisplayWidth - this.logo.width) / 2;
                const centerY = (this.canvasDisplayHeight - this.logo.height) / 2;
                const snapThreshold = 20;
                
                if (Math.abs(newX - centerX) < snapThreshold) newX = centerX;
                if (Math.abs(newY - centerY) < snapThreshold) newY = centerY;
                
                this.logo.x = newX;
                this.logo.y = newY;
                
                // Throttle render during dragging for mobile performance
                if (!this._dragRenderScheduled) {
                    this._dragRenderScheduled = true;
                    requestAnimationFrame(() => {
                        this.render();
                        this._dragRenderScheduled = false;
                    });
                }
            }
            
            handleMouseUp() {
                this.isDragging = false;
                this.render();
            }

            // Touch event handlers for mobile support
            handleTouchStart(e) {
                const touch = e.touches[0];
                this.handleMouseDown({
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
                // Only prevent default if we're starting to drag
                if (this.isDragging) {
                    e.preventDefault();
                }
            }

            handleTouchMove(e) {
                // Only prevent scrolling if we're actually dragging
                if (this.isDragging) {
                    e.preventDefault();
                }
                const touch = e.touches[0];
                this.handleMouseMove({
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
            }
            
            async exportCanvas() {
                const exportNote = document.getElementById('exportNote');
                exportNote.textContent = 'Preparing export...';
                
                try {
                    if (!this.currentMedia) {
                        throw new Error('No media loaded for export');
                    }
                
                    // Export image
                    await this.exportImage(exportNote);
                    
                } catch (error) {
                    console.error('Export failed completely:', error);
                    exportNote.textContent = 'Export failed: ' + error.message;
                    setTimeout(() => {
                        exportNote.textContent = '';
                    }, 5000);
                }
            }

            async exportImage(exportNote) {
                exportNote.textContent = 'Creating high-resolution export...';
                
                // Get media dimensions
                const mediaWidth = this.currentMedia.naturalWidth || this.currentMedia.width || 800;
                const mediaHeight = this.currentMedia.naturalHeight || this.currentMedia.height || 600;
                
                console.log('Export: Media dimensions:', mediaWidth, 'x', mediaHeight);
                
                // Create export canvas at full media resolution
                const canvas = document.createElement('canvas');
                canvas.width = mediaWidth;
                canvas.height = mediaHeight;
                const ctx = canvas.getContext('2d');
                
                // Draw media
                ctx.drawImage(this.currentMedia, 0, 0, mediaWidth, mediaHeight);
                console.log('Export: Media drawn to canvas');
                
                // Test if canvas is safe to export BEFORE adding logo
                let canExport = false;
                try {
                    const testData = canvas.toDataURL('image/png', 0.1);
                    canExport = (testData && testData !== 'data:,');
                    console.log('Export: Canvas is safe to export:', canExport);
                } catch (testErr) {
                    console.error('Export: Canvas is tainted, cannot export:', testErr);
                    throw new Error('Cannot export: Image is from external domain. Please upload image from your computer.');
                }
                
                // Draw logo if it exists AND canvas is safe
                if (this.logo && canExport) {
                    console.log('Export: Logo detected, preparing to draw...');
                    
                    // Ensure logo is rasterized (bitmap version is safer)
                    if (!this.logoBitmap || !this.logoBitmap.complete) {
                        console.log('Export: Rasterizing logo...');
                        exportNote.textContent = 'Preparing logo...';
                        try {
                            await this.rasterizeLogoBitmap();
                        } catch (rasterErr) {
                            console.warn('Export: Rasterization failed:', rasterErr);
                        }
                    }
                    
                    // Use bitmap version if available, otherwise original
                    let logoSrc = this.logoBitmap || this.logoImage;
                    
                    if (logoSrc && logoSrc.complete) {
                        // Calculate logo position and size for export
                        const rect = this.getMediaDrawRect();
                        const scale = mediaWidth / rect.drawWidth;
                        
                        const logoX = (this.logo.x - rect.offsetX) * scale;
                        const logoY = (this.logo.y - rect.offsetY) * scale;
                        const logoW = this.logo.width * scale;
                        const logoH = this.logo.height * scale;
                        
                        console.log('Export: Drawing logo at:', {x: logoX, y: logoY, w: logoW, h: logoH});
                        
                        // Try drawing logo - if it taints canvas, we'll catch it
                        try {
                            ctx.save();
                            ctx.globalAlpha = this.logo.opacity || 1;
                            ctx.imageSmoothingEnabled = true;
                            ctx.imageSmoothingQuality = 'high';
                            
                            // Apply color tint if color is set (same logic as render())
                            if (this.logo.color && this.logo.color !== '#00FFFF') {
                                console.log('Export: Applying color:', this.logo.color);
                                
                                // Use cached colored bitmap if available and color hasn't changed
                                if (this.coloredLogoBitmap && this.lastLogoColor === this.logo.color) {
                                    console.log('Export: Using cached colored bitmap');
                                    ctx.drawImage(this.coloredLogoBitmap, logoX, logoY, logoW, logoH);
                                } else {
                                    // Generate colored version
                                    const hex = this.logo.color.replace('#', '');
                                    const r = parseInt(hex.substr(0, 2), 16);
                                    const g = parseInt(hex.substr(2, 2), 16);
                                    const b = parseInt(hex.substr(4, 2), 16);
                                    
                                    // Use high-res source for coloring
                                    const sourceWidth = logoSrc.naturalWidth || logoSrc.width;
                                    const sourceHeight = logoSrc.naturalHeight || logoSrc.height;
                                    
                                    // Create temp canvas at source resolution
                                    const tempCanvas = document.createElement('canvas');
                                    tempCanvas.width = sourceWidth;
                                    tempCanvas.height = sourceHeight;
                                    const tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true });
                                    tempCtx.imageSmoothingEnabled = true;
                                    tempCtx.imageSmoothingQuality = 'high';
                                    
                                    // Draw and color at full resolution
                                    tempCtx.drawImage(logoSrc, 0, 0, sourceWidth, sourceHeight);
                                    const imageData = tempCtx.getImageData(0, 0, sourceWidth, sourceHeight);
                                    const data = imageData.data;
                                    
                                    for (let i = 0; i < data.length; i += 4) {
                                        if (data[i + 3] > 0) {
                                            const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3 / 255;
                                            data[i] = r * brightness;
                                            data[i + 1] = g * brightness;
                                            data[i + 2] = b * brightness;
                                        }
                                    }
                                    
                                    tempCtx.putImageData(imageData, 0, 0);
                                    ctx.drawImage(tempCanvas, logoX, logoY, logoW, logoH);
                                }
                            } else {
                                ctx.drawImage(logoSrc, logoX, logoY, logoW, logoH);
                            }
                            
                            ctx.restore();
                            
                            // Test again after drawing logo
                            const testData2 = canvas.toDataURL('image/png', 0.1);
                            if (testData2 && testData2 !== 'data:,') {
                                console.log('Export: ‚úì Logo drawn successfully!');
                            } else {
                                throw new Error('Logo tainted canvas');
                            }
                        } catch (logoErr) {
                            console.error('Export: Logo caused taint, redrawing without logo:', logoErr);
                            // Redraw without logo
                            ctx.clearRect(0, 0, mediaWidth, mediaHeight);
                            ctx.drawImage(this.currentMedia, 0, 0, mediaWidth, mediaHeight);
                            exportNote.textContent = 'Exporting without logo (CORS issue)...';
                        }
                    } else {
                        console.warn('Export: Logo source not available');
                    }
                }
                
                // Export using dataURL
                exportNote.textContent = 'Generating download...';
                
                try {
                    const dataURL = canvas.toDataURL('image/png', 1.0);
                    
                    if (!dataURL || dataURL === 'data:,') {
                        throw new Error('Failed to generate image data');
                    }
                    
                    const a = document.createElement('a');
                    a.href = dataURL;
                    a.download = 'core-editor-export.png';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    
                    console.log('Export: ‚úì Download completed successfully! Data URL length:', dataURL.length);
                    exportNote.textContent = 'Export completed!';
                    setTimeout(() => exportNote.textContent = '', 2000);
                    
                } catch (err) {
                    console.error('Export: Final export failed:', err);
                    throw new Error('Failed to export image. The image may be from an external domain.');
                }
            }

            async ensureLogo() {
                if (this.logoImage && this.logoImage.complete) return;
                
                return new Promise((resolve) => {
                    if (!this.logoImage) {
                        this.logoImage = new Image();
                        this.logoImage.onload = () => {
                            this.logoImageLoaded = true;
                            resolve();
                        };
                        this.logoImage.onerror = () => resolve();
                        
                        // Load SVG as data URL to avoid CORS
                        fetch('/dashboard/newcorelogo.svg')
                            .then(resp => resp.text())
                            .then(svgText => {
                                const dataUrl = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svgText);
                                this.logoImage.src = dataUrl;
                            })
                            .catch(() => {
                                this.logoImage.src = '/dashboard/newcorelogo.svg';
                            });
                    } else {
                        resolve();
                    }
                });
            }

            // Fallback export method using toDataURL
            async fallbackExport(canvas, exportNote) {
                try {
                    console.log('Using fallback export method with toDataURL');
                    exportNote.textContent = 'Using fallback export method...';
                    
                    let dataURL;
                    try {
                        dataURL = canvas.toDataURL('image/png', 1.0);
                    } catch (err) {
                        console.warn('toDataURL failed on provided canvas, regenerating safe canvas without logo:', err?.message || err);
                    }
                    
                    if (!dataURL || dataURL === 'data:,') {
                        console.log('Fallback: initial toDataURL empty; attempting high-res with logo...');
                        // Try a high-res sanitized export with logo first
                        try {
                            if (this.logo && (!this.logoBitmap || !this.logoBitmap.complete)) {
                                try { await this.rasterizeLogoBitmap(); } catch (e) { console.warn('Rasterize during fallback failed:', e); }
                            }
                            const hi = this.createHighResExport();
                            console.log('High-res export canvas size:', hi.width, 'x', hi.height);
                            dataURL = hi.toDataURL('image/png', 1.0);
                        } catch (hiErr) {
                            console.warn('High-res fallback with logo failed:', hiErr?.message || hiErr);
                        }
                    }
                    if (!dataURL || dataURL === 'data:,') {
                        console.log('Fallback: high-res with logo failed; exporting display-res without logo...');
                        // As a last resort, export display-resolution media-only (no logo) to avoid CORS taint
                        try {
                            const safe = document.createElement('canvas');
                            safe.width = this.canvasDisplayWidth || 800;
                            safe.height = this.canvasDisplayHeight || 600;
                            const sctx = safe.getContext('2d');
                            sctx.imageSmoothingEnabled = true;
                            sctx.imageSmoothingQuality = 'high';
                            const media = this.currentMedia;
                            if (!media) throw new Error('No media available for fallback');
                            const mediaAspect = (media.videoWidth && media.videoHeight) ? 
                                (media.videoWidth / media.videoHeight) : 
                                ((media.naturalWidth || media.width) / (media.naturalHeight || media.height));
                            const canvasAspect = safe.width / safe.height;
                            let dw, dh, ox, oy;
                            if (mediaAspect > canvasAspect) {
                                dw = safe.width;
                                dh = safe.width / mediaAspect;
                                ox = 0;
                                oy = (safe.height - dh) / 2;
                            } else {
                                dh = safe.height;
                                dw = safe.height * mediaAspect;
                                ox = (safe.width - dw) / 2;
                                oy = 0;
                            }
                            sctx.drawImage(media, ox, oy, dw, dh);
                            dataURL = safe.toDataURL('image/png', 1.0);
                            console.log('Media-only fallback size:', safe.width, 'x', safe.height);
                            exportNote.textContent = 'Exported without logo overlay due to browser security (CORS).';
                            setTimeout(() => { exportNote.textContent = ''; }, 4000);
                        } catch (safeErr) {
                            console.error('Safe fallback failed:', safeErr);
                            throw new Error('Safe fallback failed');
                        }
                    }
                    
                    const a = document.createElement('a');
                    a.href = dataURL;
                    a.download = 'core-editor-image.png';
                    
                    // Dodaj element do dokumentu tymczasowo
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    
                    exportNote.textContent = 'Image exported successfully!';
                    console.log('Export complete (dataURL length):', dataURL?.length || 0);
                    setTimeout(() => {
                        exportNote.textContent = '';
                    }, 2000);
                    
                } catch (error) {
                    console.error('Fallback export also failed:', error);
                    exportNote.textContent = 'Export failed completely. Please try refreshing the page.';
                    setTimeout(() => {
                        exportNote.textContent = '';
                    }, 5000);
                }
            }

            // Fallback export method for video frames
            fallbackExportFrame(canvas, exportNote) {
                try {
                    console.log('Using fallback frame export method with toDataURL');
                    exportNote.textContent = 'Using fallback export method...';
                    
                    const dataURL = canvas.toDataURL('image/png', 1.0);
                    
                    if (!dataURL || dataURL === 'data:,') {
                        throw new Error('Canvas toDataURL returned empty result');
                    }
                    
                    const a = document.createElement('a');
                    a.href = dataURL;
                    a.download = 'core-editor-frame.png';
                    
                    // Dodaj element do dokumentu tymczasowo
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    
                    exportNote.textContent = 'High quality frame exported!';
                    setTimeout(() => {
                        exportNote.textContent = 'Note: On this device, only frame export is available';
                    }, 3000);
                    
                } catch (error) {
                    console.error('Fallback frame export also failed:', error);
                    exportNote.textContent = 'Frame export failed completely. Please try refreshing the page.';
                    setTimeout(() => {
                        exportNote.textContent = 'Note: On this device, only frame export is available';
                    }, 5000);
                }
            }

            createHighResExport() {
                // Get original media dimensions
                const mediaWidth = this.currentMedia.naturalWidth || this.currentMedia.width;
                const mediaHeight = this.currentMedia.naturalHeight || this.currentMedia.height;
                
                console.log('Creating high-res export:', { mediaWidth, mediaHeight });
                
                // Test if canvas will be tainted by trying to read a small piece
                try {
                    const testCanvas = document.createElement('canvas');
                    testCanvas.width = 1;
                    testCanvas.height = 1;
                    const testCtx = testCanvas.getContext('2d');
                    testCtx.drawImage(this.currentMedia, 0, 0, 1, 1);
                    testCanvas.toDataURL(); // This will throw if tainted
                    console.log('Canvas should not be tainted');
                } catch (taintError) {
                    console.warn('Canvas will be tainted, but continuing with export:', taintError.message);
                }
                
                if (!mediaWidth || !mediaHeight || mediaWidth <= 0 || mediaHeight <= 0) {
                    console.error('Invalid media dimensions for export:', { mediaWidth, mediaHeight });
                    // Fallback to display canvas size
                    const fallbackWidth = this.canvasDisplayWidth || 800;
                    const fallbackHeight = this.canvasDisplayHeight || 600;
                    console.log('Using fallback dimensions:', { fallbackWidth, fallbackHeight });
                }
                
                const finalWidth = (mediaWidth && mediaWidth > 0) ? mediaWidth : (this.canvasDisplayWidth || 800);
                const finalHeight = (mediaHeight && mediaHeight > 0) ? mediaHeight : (this.canvasDisplayHeight || 600);
                
                // Create export canvas at original resolution
                const exportCanvas = document.createElement('canvas');
                exportCanvas.width = finalWidth;
                exportCanvas.height = finalHeight;
                const exportCtx = exportCanvas.getContext('2d');
                
                if (!exportCtx) {
                    console.error('Failed to get 2D context from export canvas');
                    throw new Error('Cannot create export canvas context');
                }
                
                // Draw media at full resolution
                try {
                    exportCtx.drawImage(this.currentMedia, 0, 0, finalWidth, finalHeight);
                } catch (error) {
                    console.error('Failed to draw media to export canvas:', error);
                    throw new Error('Cannot draw media to export canvas: ' + error.message);
                }
                
                // Draw logo at proportionally scaled size
                if (this.logo && this.logoImageLoaded && this.logoImage && this.logoImage.complete) {
                    console.log('Export: Logo state check passed - drawing logo...');
                    console.log('Logo object:', this.logo);
                    console.log('Logo bitmap:', this.logoBitmap ? 'exists' : 'null');
                    console.log('Logo image:', this.logoImage ? 'exists' : 'null');
                    
                    // Ensure we have accurate logo aspect ratio resolved (for SVG)
                    // Note: createHighResExport is sync, but ensureLogoAspectRatio sets cached ratio if already known
                    if (!this.logoAspectRatio || !isFinite(this.logoAspectRatio)) {
                        const nw = this.logoImage.naturalWidth || this.logoImage.width;
                        const nh = this.logoImage.naturalHeight || this.logoImage.height;
                        if (nw && nh) this.logoAspectRatio = nw / nh; else this.logoAspectRatio = 1;
                    }
                    // Map from what the user sees (contain-fit with offsets) to full-resolution media space
                    const rect = this.getMediaDrawRect();
                    
                    // Use UNIFORM scale to preserve logo aspect ratio
                    // Choose the same scale for both X and Y based on media scaling
                    const uniformScale = finalWidth / rect.drawWidth; // or finalHeight / rect.drawHeight - both should be the same
                    
                    // Calculate export logo position and size using uniform scale
                    const exportLogoX = (this.logo.x - rect.offsetX) * uniformScale;
                    const exportLogoY = (this.logo.y - rect.offsetY) * uniformScale;
                    const exportLogoWidth = this.logo.width * uniformScale;
                    const exportLogoHeight = this.logo.height * uniformScale;

                    // ZAWSZE u≈ºywaj logoBitmap je≈õli istnieje, inaczej logoImage
                    const srcImg = this.logoBitmap || this.logoImage;
                    const validDims = exportLogoWidth > 0 && exportLogoHeight > 0 && isFinite(exportLogoWidth) && isFinite(exportLogoHeight);

                    console.log('Export logo params:', {
                        x: exportLogoX,
                        y: exportLogoY,
                        width: exportLogoWidth,
                        height: exportLogoHeight,
                        srcImg: srcImg ? 'exists' : 'null',
                        validDims: validDims
                    });

                    if (srcImg && validDims) {
                        try {
                            exportCtx.save();
                            exportCtx.globalAlpha = this.logo.opacity;
                            exportCtx.imageSmoothingEnabled = true;
                            exportCtx.imageSmoothingQuality = 'high';
                            exportCtx.drawImage(srcImg, exportLogoX, exportLogoY, exportLogoWidth, exportLogoHeight);
                            exportCtx.restore();
                            console.log('‚úì Logo drawn successfully on export canvas!');
                        } catch (logoErr) {
                            console.error('‚úó Failed to draw logo on export:', logoErr);
                        }
                    } else {
                        console.warn('‚úó Skipping logo draw - srcImg:', !!srcImg, 'validDims:', validDims);
                    }
                } else {
                    console.warn('‚úó Logo check failed at start of draw:', {
                        hasLogo: !!this.logo,
                        logoImageLoaded: this.logoImageLoaded,
                        hasLogoImage: !!this.logoImage,
                        logoImageComplete: this.logoImage ? this.logoImage.complete : false
                    });
                }
                
                return exportCanvas;
            }

            // Compute how the media is drawn inside the editor canvas (contain-fit)
            getMediaDrawRect() {
                if (!this.currentMedia) {
                    return { drawWidth: this.canvasDisplayWidth, drawHeight: this.canvasDisplayHeight, offsetX: 0, offsetY: 0 };
                }
                const mediaAspect = (this.currentMedia.naturalWidth || this.currentMedia.width) /
                    (this.currentMedia.naturalHeight || this.currentMedia.height);
                const canvasAspect = this.canvasDisplayWidth / this.canvasDisplayHeight;
                let drawWidth, drawHeight, offsetX, offsetY;
                if (mediaAspect > canvasAspect) {
                    drawWidth = this.canvasDisplayWidth;
                    drawHeight = this.canvasDisplayWidth / mediaAspect;
                    offsetX = 0;
                    offsetY = (this.canvasDisplayHeight - drawHeight) / 2;
                } else {
                    drawHeight = this.canvasDisplayHeight;
                    drawWidth = this.canvasDisplayHeight * mediaAspect;
                    offsetX = (this.canvasDisplayWidth - drawWidth) / 2;
                    offsetY = 0;
                }
                return { drawWidth, drawHeight, offsetX, offsetY };
            }
            
            clearCanvas() {
                this.currentMedia = null;
                this.mediaType = null;
                this.logo = null;
                this.logoSubject = null;
                this.selectedCoreStyle = null;
                
                // Reset core style selection
                document.querySelectorAll('.core-style-card').forEach(c => c.classList.remove('selected'));
                // Reset subject selection
                document.querySelectorAll('.subject-btn').forEach(btn => btn.classList.remove('selected'));
                
                this.uploadPlaceholder.style.display = 'flex';
                this.canvas.style.display = 'none';
                this.clearCanvasBtn.style.display = 'none';
                
                // Kontrolki pozostajƒÖ widoczne, ale przyciski disabled
                this.addLogoBtn.disabled = true;
                this.styleToggleBtn.disabled = true;
                this.exportBtn.disabled = true;
                
                // Ukryj dodatkowe kontrolki logo
                if (this.removeLogoBtn) this.removeLogoBtn.style.display = 'none';
                if (this.centerLogoBtn) this.centerLogoBtn.style.display = 'none';
                if (this.logoSizeControl) this.logoSizeControl.style.display = 'none';
                if (this.logoOpacityControl) this.logoOpacityControl.style.display = 'none';
                if (this.logoColorControl) this.logoColorControl.style.display = 'none';
                
                this.ctx.clearRect(0, 0, this.canvasDisplayWidth, this.canvasDisplayHeight);
            }
        }
        
        // Initialize Core Editor when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            const coreEditor = new CoreEditor();
        });
        
        // Mobile Notice Functions
        function closeMobileNotice() {
            const notice = document.getElementById('mobileNotice');
            if (notice) {
                notice.style.transition = 'transform 0.3s ease';
                notice.style.transform = 'translateY(100%)';
                setTimeout(() => {
                    notice.style.display = 'none';
                }, 300);
            }
        }
        
        // Fallback - je≈õli DOMContentLoaded ju≈º siƒô wykona≈Ç
        if (document.readyState === 'loading') {
            // DOM wciƒÖ≈º siƒô ≈Çaduje, bƒôdziemy czekaƒá na event
        } else {
            // DOM ju≈º za≈Çadowany
            const coreEditor = new CoreEditor();
        }
    </script>
</body>
</html>

